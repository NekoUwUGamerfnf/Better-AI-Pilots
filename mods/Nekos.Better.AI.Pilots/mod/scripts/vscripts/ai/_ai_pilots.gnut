untyped

global const NPC_TITAN_PILOT_PROTOTYPE = 0
global function AiPilots_Init

global function CaptainThink


global function NpcPilotCallTitanThink
global function NpcPilotStopCallTitanThink
global function NpcPilotCallsInAndEmbarksTitan
global function NpcPilotRunsToAndEmbarksFallingTitan
global function NpcPilotCallsInTitan
global function NpcPilotEmbarksTitan
global function NpcPilotDisembarksTitan
global function NpcPilotBecomesTitan
global function NpcTitanBecomesPilot
global function TitanHasNpcPilot
global function NpcPilotGetPetTitan
global function NpcPilotSetPetTitan

global function NpcSetNextTitanRespawnAvailable
global function NpcResetNextTitanRespawnAvailable

global function AddCallback_OnNpcTitanBecomesPilot
global function AddCallback_OnNpcPilotBecomesTitan

// Custom Functions
global function GiveTitanAutoEject
global function RemoveTitanAutoEject
global function GiveTitanDeathEject
global function RemoveTitanDeathEject
global function SpawnPilotInTitan
global function SpawnPilotWithTitan
global function SpawnPilot

global struct NPCPilotStruct
{
	bool isValid = false
	bool titanstanding = false

	int team
	int spawnflags
	float accuracy
	float proficiency
	float health
	float physDamageScale
	//string weapon
	array <string> weapon // Use Array Because We Added Anti Titan Weapons
	string squadName

	asset modelAsset
	string title

	bool isInvulnerable
}

struct
{
table<entity, int> titanready // Based On Pilots Kills Original Titanfall Devs Were Gonna Do This Before It Was Scrapped
table<entity, int> smokecount // Titan Smoke Count
table<entity, bool> autoeject // Ejects The Titan On Doom State
table<entity, bool> deatheject // Ejects The Titan On Death
table<entity, bool> titanisbeingembarked
array<string> pilotweapons = [
"mp_weapon_rspn101_og",
"mp_weapon_r97",
"mp_weapon_car",
"mp_weapon_vinson",
"mp_weapon_epg",
"mp_weapon_smr",
"mp_weapon_lmg",
"mp_weapon_rspn101",
"mp_weapon_car",
"mp_weapon_hemlok",
"mp_weapon_lstar",
"mp_weapon_hemlok_smg"
]
array<string> pilotantititanweapons = [
"mp_weapon_arc_launcher",
"mp_weapon_rocket_launcher",
"mp_weapon_defender"
]
array<asset> pilotmodels = [
$"models/humans/pilots/pilot_medium_geist_m.mdl",
$"models/humans/pilots/pilot_medium_geist_f.mdl",
$"models/humans/pilots/pilot_medium_stalker_m.mdl",
$"models/humans/pilots/pilot_medium_stalker_f.mdl",
$"models/humans/pilots/pilot_medium_reaper_m.mdl",
$"models/humans/pilots/pilot_medium_reaper_f.mdl"
]
array<string> pilotnames = [
  "ShadowRider", "IronFist", "SteelFury", "NovaViper", "GhostReaper",
  "DeathPulse", "SkyReaper", "DarkRaven", "SkyForge", "ArcKnight",
  "RedTalon", "VenomFang", "GhostStrike", "EmberStorm", "TitanSlayer",
  "DreadEcho", "DarkNova", "ViperStorm", "SteelViper", "HellRider",
  "NovaRanger", "TechSaber", "TitanEcho", "FireWalker", "HyperBolt",
  "NightFury", "BlazeTitan", "ThunderRage", "IronWarden", "EchoWarrior",
  "NightReaper", "FrostStrike", "StormFury", "WarBringerX", "TalonReaper",
  "RedInferno", "StormViper", "TitanBlaze", "EchoHunter", "OmegaRider",
  "CyberStorm", "ThunderWolf", "WarLord", "EchoTitan", "NovaBlade",
  "CyberViper", "TitanFury", "NightViper", "BlazeKnight", "EchoFury",
  "RedViper", "SteelWolf", "NovaReaver", "TitanNight", "NovaTitan",
  "IronBlaze", "DarkViper", "RogueViper", "TitanCannon", "OmegaViper",
  "FrostKnight", "NovaHunter", "BlazeHunter", "RedVanguard", "OmegaBlaze",
  "StormRider", "NightReaver", "TitanFrost", "CyberKnight", "FrostViper",
  "EchoKnight", "NightTitan", "NovaStorm", "RedStorm", "EchoViper",
  "TitanRage", "NovaKnight", "EchoRider", "RedRanger", "RogueFury",
  "GhostTitan", "BlazeFury", "RogueKnight", "FrostStorm", "ViperHunter",
  "EchoAssault", "RedKnight", "GhostReaver", "NightStorm", "VortexRider",
  "RedTitan", "BlazeWarrior", "TitanReaver", "ShadowHunter", "PlasmaRider",
  "IronHunter", "NightRider", "OmegaHunter", "TitanRider"
]
}file

struct TitanEjectDamage
{
	int damage
	int damageHeavyArmor
	int innerRadius
	int outerRadius
	int explosionFlags
	int explosionForce
	int damageFlags
	int damageSourceId
}

struct TitanNukeDamage
{
	int count
	float duration
	int damage
	int damageHeavyArmor
	int innerRadius
	int outerRadius
	int explosionFlags
	int explosionForce
	int damageFlags
	int damageSourceId
}

struct DroppodStruct
{
	entity door
	bool openDoor = false
	int numGuys = 0
	int flags = 0
}

const NPC_NEXT_TITANTIME_RESET = -1
const NPC_NEXT_TITANTIME_MIN = 30 // Unused Now
const NPC_NEXT_TITANTIME_MAX = 60 // Unused Now
const NPC_NEXT_TITANTIME_INTERUPT = 15
const TITAN_PLAYEREJECT_DELAY = 0.4
const TITAN_PLAYEREJECT_DURATION = 0.8 // long enough foranimation
const MAX_EJECT_LATENCY_COMPENSATION = 0.4

function AiPilots_Init()
{
	RegisterSignal( "grenade_throw" )
	RegisterSignal( "NpcPilotBecomesTitan" )
	RegisterSignal( "NpcTitanBecomesPilot" )
	RegisterSignal( "StopCallTitanThink" )
	RegisterSignal( "NpcTitanRespawnAvailableUpdated" )
	AddSpawnCallback( "npc_pilot_elite", CaptainThink )
	AddDamageByCallback( "npc_titan", PilotTitanExecution ) // titan execution :D
	AddDamageCallback( "npc_titan", NPCNOPAIN )
	AddDamageCallback( "npc_pilot_elite", NPCNOPAIN )
	AddDamageCallbackSourceID( eDamageSourceId.auto_titan_melee, ApplyNormalMeleeIdToNPCTitan )
	AddCallback_OnNPCKilled( NPCPilotGetsKill ) // Titanfall Based On Kills :D
    AddCallback_OnPlayerKilled( NPCPilotGetsKill )
	AddDamageCallback( "npc_pilot_elite", PilotDamageAdjustments )
	AddDamageCallback( "npc_titan", PilotTitanAutoOrDeathEjectHandle )
	AddCallback_OnTitanDoomed( EjectWhenDoomed )

	level.onNpcPilotBecomesTitanCallbacks	<- []
	level.onNpcTitanBecomesPilotCallbacks	<- []

}

function ScriptCallback_OnNpcPilotBecomesTitan( pilot, titan )
{
	local result = { pilot = pilot, titan = titan }
	Signal( pilot, "NpcPilotBecomesTitan", result )
	Signal( titan, "NpcPilotBecomesTitan", result )

	foreach ( callbackFunc in level.onNpcPilotBecomesTitanCallbacks )
	{
		callbackFunc( pilot, titan )
	}
}

function ScriptCallback_OnNpcTitanBecomesPilot( pilot, titan )
{
	local result = { pilot = pilot, titan = titan }
	Signal( pilot, "NpcTitanBecomesPilot", result )
	Signal( titan, "NpcTitanBecomesPilot", result )

	foreach ( callbackFunc in level.onNpcTitanBecomesPilotCallbacks )
	{
		callbackFunc( pilot, titan )
	}
}

function AddCallback_OnNpcPilotBecomesTitan( callbackFunc )
{
	Assert( "onNpcPilotBecomesTitanCallbacks" in level )
	AssertParameters( callbackFunc, 2, "pilotNPC, titanNPC" )

	level.onNpcPilotBecomesTitanCallbacks.append( callbackFunc )
}

function AddCallback_OnNpcTitanBecomesPilot( callbackFunc )
{
	Assert( "onNpcTitanBecomesPilotCallbacks" in level )
	AssertParameters( callbackFunc, 2, "pilotNPC, titanNPC" )

	level.onNpcTitanBecomesPilotCallbacks.append( callbackFunc )
}

function NpcSetNextTitanRespawnAvailable( npc, time )
{
	Assert( "nextTitanRespawnAvailable" in npc.s )
	npc.s.nextTitanRespawnAvailable = time
	npc.Signal( "NpcTitanRespawnAvailableUpdated" )
}

function NpcResetNextTitanRespawnAvailable( npc )
{
	Assert( "nextTitanRespawnAvailable" in npc.s )
	npc.s.nextTitanRespawnAvailable = NPC_NEXT_TITANTIME_RESET
	npc.Signal( "NpcTitanRespawnAvailableUpdated" )
}

function NpcPilotStopCallTitanThink( pilot )
{
	pilot.Signal( "StopCallTitanThink" )
}

/************************************************************************************************\

########  #### ##        #######  ########       ######## ##     ## #### ##    ## ##    ##
##     ##  ##  ##       ##     ##    ##             ##    ##     ##  ##  ###   ## ##   ##
##     ##  ##  ##       ##     ##    ##             ##    ##     ##  ##  ####  ## ##  ##
########   ##  ##       ##     ##    ##             ##    #########  ##  ## ## ## #####
##         ##  ##       ##     ##    ##             ##    ##     ##  ##  ##  #### ##  ##
##         ##  ##       ##     ##    ##             ##    ##     ##  ##  ##   ### ##   ##
##        #### ########  #######     ##             ##    ##     ## #### ##    ## ##    ##

\************************************************************************************************/
void function CaptainThink( entity npc )
{
	thread threadCaptainThink( npc )
}

void function threadCaptainThink( entity npc )
{
    if( GetMapName() == "mp_wargames" && (GetGameState() < eGameState.Playing))
	return

	if( npc.GetTitle() == "#NPC_DROZ_NAME" || npc.GetTitle() == "#NPC_DAVIS_NAME" )
	return

	npc.EndSignal( "OnDestroy" )
	npc.EndSignal( "OnDeath" )

	Assert( !( "nextTitanRespawnAvailable" in npc.s ) )
	Assert( !( "petTitan" in npc.s ) )

	npc.s.petTitan <- null
	npc.s.nextTitanRespawnAvailable <- null

	//wait for in combat...
	//WaitForNpcInCombat( npc )

	//... before we call in a titan
	if ( npc.s.nextTitanRespawnAvailable == null )
		npc.s.nextTitanRespawnAvailable = RandomFloatRange( NPC_NEXT_TITANTIME_MIN, NPC_NEXT_TITANTIME_MAX )

	WaitFrame() //wait a frame for things like petTitan and nextTitanRespawnAvailable to have a chance to be set from custom scripts
	if( npc.GetModelName() == $"models/humans/pilots/sp_medium_reaper_m.mdl" )
	{
	thread RandomPilotWeapon( npc )
	thread RandomPilotName( npc )
	npc.kv.AccuracyMultiplier = 25
	npc.kv.WeaponProficiency = eWeaponProficiency.PERFECT
	thread PilotMiniMap( npc )
	thread PilotSpeedFlagsHPAndBehavior( npc )
	thread NpcPilotCallTitanThink( npc )
	thread RandomPilotModel( npc )
	}
}

void function OnFlagChanged( entity npc, array <int> flags, bool disable = false, bool istitan = false, bool isvalidpilot = false )
{
npc.EndSignal( "OnDestroy" )
npc.EndSignal( "OnDeath" )
 while ( true )
 {
  if( istitan == true )
  {
   entity soul = npc.GetTitanSoul()
   if( IsValid( soul ) )
   {
    if( isvalidpilot == true )
    {
    if( !( soul.soul.seatedNpcPilot.isValid ) )
    return
    }
	if( isvalidpilot == false )
    {
    if( soul.soul.seatedNpcPilot.isValid )
    return
    }
   }
  }
  foreach( int flag in flags )
  {
   if( disable == false )
   {
    if ( !npc.GetNPCFlag( flag ) )
    {
    npc.EnableNPCFlag( flag )
    }
   }
   if( disable == true )
   {
    if ( npc.GetNPCFlag( flag ) )
    {
    npc.DisableNPCFlag( flag )
    }
   }
  }
 WaitFrame()
 }
}

void function PilotSpeedFlagsHPAndBehavior( entity npc )
{
npc.SetNPCMoveSpeedScale( 1.25 )
npc.EnableNPCMoveFlag( NPCMF_PREFER_SPRINT )
array <int> flags 
flags.extend([ NPC_NO_PAIN, NPC_NO_GESTURE_PAIN, NPC_ALLOW_PATROL, NPC_ALLOW_INVESTIGATE, NPC_IGNORE_FRIENDLY_SOUND ])
thread OnFlagChanged( npc, flags )
array <int> disableflags 
disableflags.extend([ NPC_PAIN_IN_SCRIPTED_ANIM ])
thread OnFlagChanged( npc, disableflags, true )
npc.SetMaxHealth( 1500 )
npc.SetHealth( npc.GetMaxHealth() )
npc.SetBehaviorSelector( "behavior_sp_soldier" )
npc.SetEnemyChangeCallback( OnNPCPilotEnemyChange )
}

void function PilotMiniMap( entity npc )
{
entity pilotminimap = createpilotminimap( npc )
thread pilotminimaponpilotdeath( npc, pilotminimap )
}

entity function createpilotminimap( entity npc )
{
entity pilotminimap = CreateEntity( "npc_spectre" )
DispatchSpawn( pilotminimap )
TakeWeaponsForArray( pilotminimap, pilotminimap.GetMainWeapons() )
pilotminimap.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY
pilotminimap.Hide()
HideName( pilotminimap )
pilotminimap.SetParent( npc, "HEADFOCUS" )
pilotminimap.NotSolid()
pilotminimap.kv.CollisionGroup = 0
pilotminimap.SetInvulnerable()
SetTeam( pilotminimap, npc.GetTeam() )
NPC_NoTarget( pilotminimap )
pilotminimap.EnableNPCFlag( NPC_IGNORE_ALL )
pilotminimap.StopPhysics()
pilotminimap.Freeze()
pilotminimap.SetModel( $"models/dev/empty_model.mdl" )
return pilotminimap
}

void function pilotminimaponpilotdeath( entity npc, entity pilotminimap )
{
 while( true )
 {
if( IsValid( npc ) && IsValid( pilotminimap ) )
{
if( npc.GetTeam() != pilotminimap.GetTeam() )
SetTeam( pilotminimap, npc.GetTeam() )
}
if( IsValid( npc ) && !IsValid( pilotminimap ) )
{
pilotminimap = createpilotminimap( npc )
}
if( !IsValid( npc ) && IsValid( pilotminimap ) )
{
pilotminimap.Destroy()
return
}
WaitFrame()
 }
}

void function NPCNOPAIN( entity npc, var damageInfo )
{
 if( npc.GetNPCFlag( NPC_NO_PAIN ) || !npc.GetNPCFlag( NPC_PAIN_IN_SCRIPTED_ANIM ) )
 {
  if( !npc.IsTitan() )
  DamageInfo_AddDamageFlags( damageInfo, DAMAGEFLAG_NOPAIN )
  if( npc.IsTitan() )
  {
  entity soul = npc.GetTitanSoul()
  if( !IsValid( soul ) )
  return
  if( soul.soul.seatedNpcPilot.isValid )
  DamageInfo_AddDamageFlags( damageInfo, DAMAGEFLAG_NOPAIN )
  }
 }
}

void function ApplyNormalMeleeIdToNPCTitan( entity victim, var damageInfo )
{
entity attacker = DamageInfo_GetAttacker( damageInfo )
int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )

if( !attacker.IsNPC() )
	return

if( !attacker.IsTitan() )
    return

if ( GetTitanCharacterName( attacker ) == "ronin" && attacker.GetTitanSoul().soul.seatedNpcPilot.isValid )
{
 entity meleeWeapon = attacker.GetMeleeWeapon()
 if( IsValid( meleeWeapon ) )
 {
  if( meleeWeapon.HasMod( "super_charged" ) )
  {
  DamageInfo_SetDamageSourceIdentifier( damageInfo, eDamageSourceId.mp_titancore_shift_core )
  return
  }
 }
DamageInfo_SetDamageSourceIdentifier( damageInfo, eDamageSourceId.melee_titan_sword )
return
}

if( attacker.GetTitanSoul().soul.seatedNpcPilot.isValid )
{
DamageInfo_SetDamageSourceIdentifier( damageInfo, eDamageSourceId.melee_titan_punch )
return
}
}

void function NPCPilotGetsKill( entity ent, entity attacker, var damageInfo )
{
if( !IsValid( attacker ) )
return
if( !IsAlive( attacker ) )
return
if( attacker.GetTeam() == ent.GetTeam() )
return
if( attacker.IsPlayer() )
return
if( !attacker.IsNPC() )
return
if( attacker.GetClassName() != "npc_pilot_elite" )
return
string entclass = ent.GetClassName()
bool PlayerWasTitan = false
if( ent.IsPlayer() && ent.IsTitan() )
PlayerWasTitan = true
thread RunNPCPilotGetsKill( ent, attacker, entclass, PlayerWasTitan )
}

void function RunNPCPilotGetsKill( entity ent, entity attacker, string entclass, bool PlayerWasTitan )
{
int points = 1
if( entclass == "npc_pilot_elite" || entclass == "player" || entclass == "npc_super_spectre" || entclass == "npc_dropship" )
points = 5
if( entclass == "npc_titan" || entclass == "npc_gunship" || PlayerWasTitan == true )
points = 10
if( entclass == "npc_stalker" )
points = 3
if( entclass == "npc_spectre" )
points = 2
int originalpointscount = 0 // Crash Fix
if ( attacker in file.titanready )
originalpointscount = file.titanready[ attacker ]
int newpointscount = originalpointscount + points
if( newpointscount > 10 )
newpointscount = 10 // Cap To 10 Points So I Don't Have To Do More Coding
if ( !( attacker in file.titanready ) )
file.titanready[ attacker ] <- newpointscount
else
file.titanready[ attacker ] = newpointscount
}

void function PilotDamageAdjustments( entity pilot, var damageInfo )
{	
	if ( IsInstantDeath( damageInfo ) || DamageInfo_GetForceKill( damageInfo ) ) // force kill damage( trigger_hurt, executions ) shouldn't be handled
		return

	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	int damageType = DamageInfo_GetCustomDamageType( damageInfo )
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !IsValid( attacker ) )
		return

	int dpsTaken = int( GetTotalDamageTakenInTime( pilot, 1.0 ) )
	int maxDPSTaken = 300
	if ( dpsTaken >= maxDPSTaken )
		DamageInfo_SetDamage( damageInfo, 0 )
	else
	{
		int maxDamage = maxDPSTaken - dpsTaken
		int currentDamage = int( DamageInfo_GetDamage( damageInfo ) )
		DamageInfo_SetDamage( damageInfo, min( currentDamage, maxDamage ) )
	}
}

void function PilotTitanAutoOrDeathEjectHandle( entity titan, var damageInfo )
{
	if ( IsInstantDeath( damageInfo ) || DamageInfo_GetForceKill( damageInfo ) )	
		return

	if ( titan.ContextAction_IsBusy() )
		return

	entity soul = titan.GetTitanSoul()

	if ( !IsValid( soul ) || soul.IsEjecting() )
		return

	if ( soul.soul.seatedNpcPilot.isValid && ( (titan in file.deatheject && file.deatheject[titan] == true ) || (titan in file.autoeject && file.autoeject[titan] == true) ) )
	{
		if ( !TitanCanSurviveDamage( titan, damageInfo ) || (titan in file.autoeject && file.autoeject[titan] == true && GetDoomedState( titan )) )
		{
		    if( (titan in file.deatheject && file.deatheject[titan] == true ) && !(titan in file.autoeject && file.autoeject[titan] == true) )
			DamageInfo_SetDamage( damageInfo, 0 )

			thread TitanEjectPlayerForNPCs( titan )

			if ( IsAlive( titan ) && (titan in file.deatheject && file.deatheject[titan] == true ) && !(titan in file.autoeject && file.autoeject[titan] == true) )
				titan.SetHealth( 1 )
		}
	}
}

void function GiveTitanAutoEject( entity titan )
{
file.autoeject[ titan ] <- true
}

void function RemoveTitanAutoEject( entity titan )
{
file.autoeject[ titan ] <- false
}

void function GiveTitanDeathEject( entity titan )
{
file.deatheject[ titan ] <- true
}

void function RemoveTitanDeathEject( entity titan )
{
file.deatheject[ titan ] <- false
}

void function PilotTitanExecution( entity ent, var damageInfo )
{
thread PilotTitanExecution_thread( ent, damageInfo )
}

void function PilotTitanExecution_thread( entity ent, var damageInfo )
{
    int damageType = DamageInfo_GetCustomDamageType( damageInfo )
	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	entity attacker = DamageInfo_GetAttacker( damageInfo )

		if ( !IsAlive( ent ) || !attacker || ent.GetTeam() == attacker.GetTeam() || attacker == ent || !ent.IsTitan() || ent.IsInvulnerable() )
		return

	entity soul = ent.GetTitanSoul()
	if( attacker.IsNPC() && attacker.IsTitan() )
	{
		if( IsValid( soul ) && ( damageType & DF_MELEE ) )
		{
		    entity titanSoul = attacker.GetTitanSoul()
			if( titanSoul.soul.seatedNpcPilot.isValid && CodeCallback_IsValidMeleeExecutionTarget( attacker, ent ) )
			{
				if( GetDoomedState( ent ) && !SoulHasPassive( soul, ePassives.PAS_AUTO_EJECT ) && !ent.IsPhaseShifted() && TitanCanSurviveDamage( ent, damageInfo ) )
				{
					vector attackerStartingAngles = attacker.GetAngles()
					PilotTitanExecution_DamageEnemy( ent, damageInfo )
					DamageInfo_SetDamage( damageInfo, 0 )
					thread PilotTitanExecution_Wait( attacker, attackerStartingAngles )
					waitthread PlayerTriesSyncedMelee( attacker, ent )
				}
			}
		}
	}
}

void function PilotTitanExecution_DamageEnemy( entity ent, var damageInfo )
{
if( HasSoul( ent ) && Time() - ent.GetTitanSoul().soul.doomedStartTime < TITAN_DOOMED_INVUL_TIME )
return
ent.SetInvulnerable()
entity soul = ent.GetTitanSoul()
if( !IsValid( soul ) )
return
int damage = int( DamageInfo_GetDamage( damageInfo ) )
int shieldhealth = soul.GetShieldHealth()
int titanhealth = ent.GetHealth()
int shieldhealthdamaged = shieldhealth - damage
int shieldhealthdamagedunchanged = shieldhealthdamaged
if( shieldhealthdamaged < 0 )
shieldhealthdamaged = 0
soul.SetShieldHealth( shieldhealthdamaged )
int newdamage = damage - shieldhealthdamagedunchanged
if( newdamage < 0 )
newdamage = 0
if( newdamage > damage )
newdamage = damage
int titanhealthdamaged = titanhealth - newdamage
if( titanhealthdamaged <= 0 )
titanhealthdamaged = 1
ent.SetHealth( titanhealthdamaged )
ent.ClearInvulnerable()
}

bool function TitanCanSurviveDamage( entity titan, var damageInfo )
{
    int damage = int( DamageInfo_GetDamage( damageInfo ) )
    int validHealth = GetTitanValidHealthFromDamageInfo( titan, damageInfo )
    //print( "titan( " + string( titan ) + " )'s valid health: " + string( validHealth ) )
    return damage < validHealth
}

int function GetTitanValidHealthFromDamageInfo( entity titan, var damageInfo )
{
    if ( DamageInfo_GetForceKill( damageInfo ) )
        return 0

    const int INFINITE_HEALTH = 999999 // over max health limit, means titan won't die from damage

    entity soul = titan.GetTitanSoul()
    int healthShield = titan.GetHealth()
    if ( IsValid( soul ) )
        healthShield += soul.GetShieldHealth()
	if ( IsValid( soul ) && !GetDoomedState( titan ) && !soul.soul.skipDoomState )
	    healthShield += 2500

    if ( GetDoomedState( titan ) )
    {
        // in damage protection -- never die from current damage
        if ( IsValid( soul ) )
        {
            if ( Time() - soul.soul.doomedStartTime < TITAN_DOOMED_INVUL_TIME )
                return INFINITE_HEALTH
        }
    }
    
    return healthShield
}

void function PilotTitanExecution_Wait( entity attacker, vector attackerStartingAngles )
{
    attacker.EndSignal( "OnDestroy" )
    attacker.EndSignal( "OnDeath" )
    WaitFrame()
    while( attacker.Anim_IsActive() )
        WaitFrame()
    vector angles = attacker.GetAngles()
    // reset their x, z angles
    angles.x = attackerStartingAngles.x
    angles.z = attackerStartingAngles.z
    attacker.SetAngles( angles )
}

function NpcPilotCallTitanThink( entity pilot )
{
	Assert( pilot.IsNPC() )
	Assert( IsAlive( pilot ) )
	Assert ( !pilot.IsTitan() )

	//pilot.EndSignal( "OnDestroy" )
	//pilot.EndSignal( "OnDeath" )
	pilot.Signal( "StopCallTitanThink" )
	pilot.EndSignal( "StopCallTitanThink" )

	local count = 1 //1 titan call in at a time

	while ( true ) //this loop usually only happens once, unless the titan called in is destroyed before the living pilot can get to it
	{
	    if( !IsValid( pilot ) )
	    return
	    if( !IsAlive( pilot ) )
	    return
		entity titan = NpcPilotGetPetTitan( pilot )
		if ( !IsAlive( titan ) )
		{
			//wait for ready titan
			waitthread __WaitforTitanCallinReady( pilot )
		    if( !IsValid( pilot ) )
	        return
	        if( !IsAlive( pilot ) )
	        return

			//ready to call in - look for a good spot
			SpawnPointFP spawnPoint
			while ( true )
			{
				wait ( RandomFloatRange( 1, 2 ) )

		        if( !IsValid( pilot ) )
	            return
	            if( !IsAlive( pilot ) )
	            return

				//dont do stuff when animating on a parent
				if ( pilot.GetParent() )
					continue

			    //Don't deploy if too close to an enemy
				//if ( HasEnemyWithinDist( pilot, 300.0 ) )
					//continue

				// DO the opposite - only deploy if has an enemy within this distance
			//	if ( !HasEnemyWithinDist( pilot, 2000.0 ) )
			//		continue

				//don't do stuff if you dont have a spawnPoint
				spawnPoint = FindSpawnPointForNpcCallin( pilot, $"models/titans/medium/titan_medium_ajax.mdl", HOTDROP_TURBO_ANIM )
				if ( !spawnPoint.valid )
					continue

				break
			}

			//call in a titan, run to it, and embark
			//in SP by default, the friendlys do NOT do the beacon tell
			titan = NpcPilotCallsInAndEmbarksTitan( pilot, spawnPoint.origin, spawnPoint.angles )
		}
		local result = WaitSignal( titan, "NpcPilotBecomesTitan", "OnDeath", "OnDestroy" )
		if ( result.signal != "NpcPilotBecomesTitan" )
			continue //the titan didn't make it, lets loop back up and try again
	}
}

/************************************************************************************************\

 ######     ###    ##       ##             #### ##    ##       ######## #### ########    ###    ##    ##
##    ##   ## ##   ##       ##              ##  ###   ##          ##     ##     ##      ## ##   ###   ##
##        ##   ##  ##       ##              ##  ####  ##          ##     ##     ##     ##   ##  ####  ##
##       ##     ## ##       ##              ##  ## ## ##          ##     ##     ##    ##     ## ## ## ##
##       ######### ##       ##              ##  ##  ####          ##     ##     ##    ######### ##  ####
##    ## ##     ## ##       ##              ##  ##   ###          ##     ##     ##    ##     ## ##   ###
 ######  ##     ## ######## ########       #### ##    ##          ##    ####    ##    ##     ## ##    ##

\************************************************************************************************/

void function EmbarkedNPCTitanRodeoCounter( entity titan )
{
	thread EmbarkedNPCTitanRodeoCounter_Threaded( titan )
}

void function EmbarkedNPCTitanRodeoCounter_Threaded( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return

	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )
	soul.EndSignal( "OnDestroy" )

	float beingRodeoedTime = -1
	float lastTickRodeoHitTime = 0
	bool hasusedsmoke = false

	while ( true )
	{
		WaitFrame() // always wait a frame each loop

		titan = soul.GetTitan() // update titan
		if( !( soul.soul.seatedNpcPilot.isValid ) ) // npc pilot become invalid!
		return

		entity rodeoPilot = GetRodeoPilot( titan )
		float rodeoHitTime = soul.GetLastRodeoHitTime()
		if ( rodeoHitTime != 0 && lastTickRodeoHitTime == 0 ) // rodeo target updated!
			beingRodeoedTime = rodeoHitTime
		else if ( rodeoHitTime == 0 ) // rodeo target detached
		{
			beingRodeoedTime = -1
			hasusedsmoke = false
		}
		lastTickRodeoHitTime = rodeoHitTime

		if ( titan.Anim_IsActive() || IsValid( titan.GetParent() ) )
			continue

		//print( "beingRodeoedTime: " + string( beingRodeoedTime ) )
		// Rodeo counter: force inventory smoke to fire when getting rodeo hit recently
		if ( IsAlive( rodeoPilot ) && beingRodeoedTime != -1 )
		{
			// delay is enough!
			if( hasusedsmoke == false )
			{
				// team checks: weapons like satchel can trigger friendly rodeo alert...
				if ( rodeoPilot.GetTeam() == titan.GetTeam() )
					continue

			    if( rodeoPilot.IsPlayer() )
			    {
			    if ( !PlayerHasPassive( rodeoPilot, ePassives.PAS_STEALTH_MOVEMENT ) )
			    wait 1
			    }
					
					// ammo management
					int smokeCount = 1
					bool shoulddosmoke = true
					if ( titan in file.smokecount )
					smokeCount = file.smokecount[ titan ]
					if ( smokeCount == 0 )
					{
					smokeCount = 1
					shoulddosmoke = false
					}
					if ( !( titan in file.smokecount ) )
                    file.smokecount[ titan ] <- smokeCount - 1
                    else
                    file.smokecount[ titan ] = smokeCount - 1

					if ( shoulddosmoke == true )
					{
					hasusedsmoke = true
					TitanSmokescreen( titan )
					}
			}
		}
	}
}

void function TitanSmokescreen( entity ent )
{
	SmokescreenStruct smokescreen
		
	smokescreen.isElectric = true
	smokescreen.ownerTeam = ent.GetTeam()
	smokescreen.attacker = ent
	smokescreen.inflictor = ent
	smokescreen.damageInnerRadius = 320.0
	smokescreen.damageOuterRadius = 375.0
	smokescreen.dangerousAreaRadius = 1.0
	smokescreen.dpsPilot = 45
	smokescreen.dpsTitan = 450
	smokescreen.damageDelay = 1.0
	smokescreen.blockLOS = false

	vector eyeAngles = <0.0, ent.EyeAngles().y, 0.0>
	smokescreen.angles = eyeAngles

	vector forward = AnglesToForward( eyeAngles )
	vector testPos = ent.GetOrigin() + forward * 240.0
	vector basePos = testPos

	float trace = TraceLineSimple( ent.EyePosition(), testPos, ent )
	if ( trace != 1.0 )
		basePos = ent.GetOrigin()

	float fxOffset = 200.0
	float fxHeightOffset = 148.0

	smokescreen.origin = basePos

	smokescreen.fxOffsets = [ < -fxOffset, 0.0, 20.0>,
							  <0.0, fxOffset, 20.0>,
							  <0.0, -fxOffset, 20.0>,
							  <0.0, 0.0, fxHeightOffset>,
							  < -fxOffset, 0.0, fxHeightOffset> ]

	Smokescreen( smokescreen )
}

void function SpawnPilotInTitan( int team, bool godmode = false, vector location = < 0, 0, 0 >, vector angle = < 0, 0, 0 > )
{
    if( !IsNewThread() )
	{
	thread SpawnPilotInTitan( team, godmode, location, angle )
	return
	}
	vector origin = < 0, 0, 0 >
	vector angles = < 0, 0, 0 >
    if( location == < 0, 0, 0 > && angle == < 0, 0, 0 > )
	{
	entity droppod = GetSpawnpoint( team )
	if( !IsValid( droppod ) )
	return
	droppod.s.lastUsedTime <- Time()
	origin = droppod.GetOrigin()
	angle = droppod.GetAngles()
	}
	if( location != < 0, 0, 0 > )
	origin = location
	if( angle != < 0, 0, 0 > )
	angles = angle
	entity pilot = CreateEntity( "npc_pilot_elite" )
	pilot.SetOrigin( origin )
	DispatchSpawn( pilot )
	pilot.SetInvulnerable()
	thread RandomPilotWeapon( pilot )
	thread RandomPilotName( pilot )
	pilot.kv.AccuracyMultiplier = 25
	pilot.kv.WeaponProficiency = eWeaponProficiency.PERFECT
	thread RandomPilotModel( pilot )
	pilot.EnableNPCFlag( NPC_IGNORE_ALL )
	pilot.kv.VisibilityFlags = ~ENTITY_VISIBLE_TO_EVERYONE
	pilot.s.petTitan <- null
	pilot.s.nextTitanRespawnAvailable <- null
	array<string> settingsArray = GetAllowedTitanAISettings()
	bool usewarpfall = false
	bool usedomeshieldwarpfall = false

	settingsArray.extend([ "npc_titan_auto_atlas_ion_prime", "npc_titan_auto_ogre_scorch_prime", "npc_titan_auto_stryder_northstar_prime", "npc_titan_auto_stryder_ronin_prime", "npc_titan_auto_atlas_tone_prime", "npc_titan_auto_ogre_legion_prime" ])
	string titanSettings = settingsArray.getrandom()
	if ( RandomInt( 2 ) < 1 )
	{
	usewarpfall = true
	}
   if( usewarpfall == false )
   {
	if ( GetMapName().find( "mp_lf_") != null || GetMapName() == "mp_grave" )
	{
	usedomeshieldwarpfall = true
	}
   }
	if( usewarpfall == true )
	{
	NPCPrespawnWarpfallSequence( titanSettings, origin, angles )
	}
	if( usedomeshieldwarpfall == true )
	{
	NPCPrespawnWarpfallSequenceModded( titanSettings, origin, angles )
	}
	string setFile = GetRandomTitanSetFile( titanSettings )
	entity titan = CreateNPCTitan( setFile, team, origin, angles )
	SetSpawnOption_AISettings( titan, titanSettings )
	DispatchSpawn( titan )
	thread NpcPilotBecomesTitan( pilot, titan )

	//call it in
   if ( usewarpfall == false )
   {
	if( usedomeshieldwarpfall == false )
	{
	thread NPCTitanHotdrops( titan, true )
	}
   }
   else
   {
   thread NPCTitanHotdropsWarpfall( titan, true )
   }
	if( usedomeshieldwarpfall == true )
	{
	thread NPCTitanHotdrops( titan, true, "at_hotdrop_drop_2knee_turbo_upgraded" )
	}
	int randomtitancamo = RandomIntRange( 0, 160 ) // 159 is all camos
	titan.SetSkin( 2 ) // titan skin has skinIndex of 2
	titan.SetCamo( randomtitancamo ) // set camo to random
	thread AutoTitanLoadout( titan )
	thread MonitorTitanCore( titan )
	if( godmode == true )
	titan.SetInvulnerable()

	//get the titan ready to be embarked
	SetStanceKneel( titan.GetTitanSoul() )
	thread RandomPilotName( titan )
	UpdateEnemyMemoryFromTeammates( titan )
}

void function SpawnPilotWithTitan( int team, bool godmode = false, vector location = < 0, 0, 0 >, vector angle = < 0, 0, 0 > )
{
    if( !IsNewThread() )
	{
	thread SpawnPilotWithTitan( team, godmode, location, angle )
	return
	}
	vector pos = < 0, 0, 0 >
	vector angles = < 0, 0, 0 >
    if( location == < 0, 0, 0 > && angle == < 0, 0, 0 > )
	{
	entity droppod = GetSpawnpoint( team )
	if( !IsValid( droppod ) )
	return
	droppod.s.lastUsedTime <- Time()
	pos = droppod.GetOrigin()
	angle = droppod.GetAngles()
	}
	if( location != < 0, 0, 0 > )
	pos = location
	if( angle != < 0, 0, 0 > )
	angles = angle
	entity pod = CreateDropPod( pos, angles )
	entity poddoor = DropPodDoor( pod )

	array<entity> npcs
	for ( int i = 0; i < 1; i++ )
	{
		entity entitynpc = CreateEntity( "npc_pilot_elite" )
		entitynpc.SetOrigin( pos )
		DispatchSpawn( entitynpc )
		SetTeam( entitynpc, team )
	    thread RandomPilotWeapon( entitynpc )
	    thread RandomPilotName( entitynpc )
	    entitynpc.kv.AccuracyMultiplier = 25
	    entitynpc.kv.WeaponProficiency = eWeaponProficiency.PERFECT
	    thread PilotSpeedFlagsHPAndBehavior( entitynpc )
	    thread RandomPilotModel( entitynpc )
	    entitynpc.s.petTitan <- null
	    entitynpc.s.nextTitanRespawnAvailable <- null
		if( godmode == true )
		entitynpc.SetInvulnerable()
		
		entitynpc.SetParent( pod, "ATTACH", true )
		entitynpc.kv.VisibilityFlags = ~ENTITY_VISIBLE_TO_EVERYONE
		npcs.append( entitynpc )
	}

	thread NpcPilotCallsInAndEmbarksTitan( npcs.getrandom(), pos, angles, 2.5, true )
	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, angles )

	string squadName = MakeSquadName( team, UniqueString( "" ) )
	
	foreach( entity pilot in npcs )
	pilot.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
	foreach( entity pilot in npcs )
	thread PilotMiniMap( pilot )
	DropPodOpenDoorModded( pod, poddoor )
	thread ActivateFireteamDropPodModded( pod, npcs, poddoor )
}

void function SpawnPilot( int team, bool godmode = false, vector location = < 0, 0, 0 >, vector angle = < 0, 0, 0 > )
{
    if( !IsNewThread() )
	{
	thread SpawnPilot( team, godmode, location, angle )
	return
	}
	vector pos = < 0, 0, 0 >
	vector angles = < 0, 0, 0 >
    if( location == < 0, 0, 0 > && angle == < 0, 0, 0 > )
	{
	entity droppod = GetSpawnpoint( team )
	if( !IsValid( droppod ) )
	return
	droppod.s.lastUsedTime <- Time()
	pos = droppod.GetOrigin()
	angle = droppod.GetAngles()
	}
	if( location != < 0, 0, 0 > )
	pos = location
	if( angle != < 0, 0, 0 > )
	angles = angle
	entity pod = CreateDropPod( pos, angles )
	entity poddoor = DropPodDoor( pod )
		
	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, angles )

	string squadName = MakeSquadName( team, UniqueString( "" ) )
	array<entity> npcs
	for ( int i = 0; i < 1; i++ )
	{
		entity entitynpc = CreateEntity( "npc_pilot_elite" )
		entitynpc.SetOrigin( pos )
		DispatchSpawn( entitynpc )
		SetTeam( entitynpc, team )
	    thread RandomPilotWeapon( entitynpc )
	    thread RandomPilotName( entitynpc )
	    entitynpc.kv.AccuracyMultiplier = 25
	    entitynpc.kv.WeaponProficiency = eWeaponProficiency.PERFECT
	    thread PilotMiniMap( entitynpc )
	    thread PilotSpeedFlagsHPAndBehavior( entitynpc )
	    thread NpcPilotCallTitanThink( entitynpc )
	    thread RandomPilotModel( entitynpc )
	    entitynpc.s.petTitan <- null
	    entitynpc.s.nextTitanRespawnAvailable <- null
		if( godmode == true )
		entitynpc.SetInvulnerable()
		
		entitynpc.SetParent( pod, "ATTACH", true )
		npcs.append( entitynpc )
	}
	
	DropPodOpenDoorModded( pod, poddoor )
	thread ActivateFireteamDropPodModded( pod, npcs, poddoor )
}

entity function GetSpawnpoint( int team )
{
 array<entity> spawns = SpawnPoints_GetTitan()
 array<entity> betterspawns
 if( spawns.len() <= 0 )
 return null
 foreach( entity spawnpoint in spawns )
 if( IsSpawnpointValid( spawnpoint, team ) )
 betterspawns.append( spawnpoint )
 if( betterspawns.len() <= 0 )
 return null
 else
 return betterspawns.getrandom()
}

bool function IsSpawnpointValid( entity spawnpoint, int team )
{
	if ( !spawnpoint.HasKey( "ignoreGamemode" ) || spawnpoint.HasKey( "ignoreGamemode" ) && spawnpoint.kv.ignoreGamemode == "0" ) // used by script-spawned spawnpoints
	{
		if ( GetSpawnpointGamemodeOverride() != "" )
		{
			string gamemodeKey = "gamemode_" + GetSpawnpointGamemodeOverride()
			if ( spawnpoint.HasKey( gamemodeKey ) && ( spawnpoint.kv[ gamemodeKey ] == "0" || spawnpoint.kv[ gamemodeKey ] == "" ) )
				return false
		}
		else if ( GameModeRemove( spawnpoint ) )
			return false
	}
		
	if ( spawnpoint.IsOccupied() || ("inuse" in spawnpoint.s && spawnpoint.s.inuse) || ("lastUsedTime" in spawnpoint.s && Time() - spawnpoint.s.lastUsedTime <= 10.0) )
		return false
	
	if ( SpawnPointInNoSpawnArea( spawnpoint.GetOrigin(), team ) )
		return false

	// Line of Sight Check, could use IsVisibleToEnemies but apparently that considers only players, not NPCs
	array< entity > enemyTitans = GetTitanArrayOfEnemies( team )
	if ( GetConVarBool( "spawnpoint_avoid_npc_titan_sight" ) )
	{
		foreach ( titan in enemyTitans )
		{
			if ( IsAlive( titan ) && titan.IsNPC() && titan.CanSee( spawnpoint ) )
				return false
		}
	}
	
	return !spawnpoint.IsVisibleToEnemies( team )
}

void function DropPodOpenDoorModded( entity pod, entity door )
{
	door.ClearParent()
	door.SetVelocity( door.GetForwardVector() * 500 )
	EmitSoundOnEntity( pod, "droppod_door_open" )
}

void function DestroyPod( entity pod, entity door )
{
pod.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
door.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
}

entity function DropPodDoor( entity pod )
{
	string attachment = "hatch"
	int attachIndex = pod.LookupAttachment( attachment )
	vector origin = pod.GetAttachmentOrigin( attachIndex )
	vector angles = pod.GetAttachmentAngles( attachIndex )

	entity prop_physics = CreateEntity( "prop_physics" )
	SetTargetName( prop_physics, "door" + UniqueString() )
	prop_physics.SetValueForModelKey( $"models/vehicle/droppod_fireteam/droppod_fireteam_door.mdl" )
	// Start Asleep
	// Debris - Don't collide with the player or other debris
	// Generate output on +USE
	prop_physics.kv.spawnflags = 261 // non solid for now
	prop_physics.kv.fadedist = -1
	prop_physics.kv.physdamagescale = 0.1
	prop_physics.kv.inertiaScale = 1.0
	prop_physics.kv.renderamt = 0
	prop_physics.kv.rendercolor = "255 255 255"

	//DispatchSpawn( prop_physics )

	prop_physics.SetOrigin( origin )
	prop_physics.SetAngles( angles )
	prop_physics.SetParent( pod, "HATCH", false )
	prop_physics.MarkAsNonMovingAttachment()

	return prop_physics
}

void function ActivateFireteamDropPodModded( entity pod, array<entity> guys, entity poddoor )
{
	if ( guys.len() >= 1 )
	{
		SetAnim( guys[0], "drop_pod_exit_anim", "pt_dp_exit_a" )
		SetAnim( guys[0], "drop_pod_idle_anim", "pt_dp_idle_a" )
	}

	if ( guys.len() >= 2 )
	{
		SetAnim( guys[1], "drop_pod_exit_anim", "pt_dp_exit_b" )
		SetAnim( guys[1], "drop_pod_idle_anim", "pt_dp_idle_b" )
	}

	if ( guys.len() >= 3 )
	{
		SetAnim( guys[2], "drop_pod_exit_anim", "pt_dp_exit_c" )
		SetAnim( guys[2], "drop_pod_idle_anim", "pt_dp_idle_c" )
	}

	if ( guys.len() >= 4 )
	{
		SetAnim( guys[3], "drop_pod_exit_anim", "pt_dp_exit_d" )
		SetAnim( guys[3], "drop_pod_idle_anim", "pt_dp_idle_d" )
	}

	foreach ( guy in guys )
	{
		if ( IsAlive( guy ) )
		{
			guy.MakeVisible()
			entity weapon = guy.GetActiveWeapon()
			if ( IsValid( weapon ) )
				weapon.MakeVisible()

			thread GuyHangsInPod( guy, pod, poddoor )
		}
	}
}

void function GuyHangsInPod( entity guy, entity pod, entity poddoor )
{
	guy.EndSignal( "OnDeath" )
	guy.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function () : ( pod, poddoor )
		{
			thread DestroyPod( pod, poddoor )
		}
	)

	string exitAnim

	guy.SetParent( pod, "ATTACH", false )

	exitAnim =  expect string ( GetAnim( guy, "drop_pod_exit_anim" ) )
	bool exitAnimExists = guy.LookupSequence( exitAnim ) != -1
	if ( exitAnimExists )
		guy.Anim_ScriptedPlay( exitAnim )

	guy.ClearParent()

	if ( exitAnimExists )
		WaittillAnimDone( guy )
	guy.Signal( "npc_deployed" )
}

void function GiveTitanSmokeEveryThirtySeconds( entity npc )
{
npc.EndSignal( "OnDestroy" )
npc.EndSignal( "OnDeath" )
 while( true )
 {
 int smokeCount = 0
  if ( npc in file.smokecount )
  {
  while( file.smokecount[ npc ] == 6 )
  WaitFrame()
  }
 if ( npc in file.smokecount )
 smokeCount = file.smokecount[ npc ]
 if ( !( npc in file.smokecount ) )
 file.smokecount[ npc ] <- smokeCount + 1
 else
 file.smokecount[ npc ] = smokeCount + 1
 wait 30.0
 }
}

entity function NpcPilotCallsInAndEmbarksTitan( entity pilot, vector origin, vector angles, float waittime = 0.0, bool dontusewarpfall = false )
{
    if( waittime != 0.0 )
	wait waittime
	entity titan = NpcPilotCallsInTitan( pilot, origin, angles, dontusewarpfall )
	thread NpcPilotRunsToAndEmbarksFallingTitan( pilot, titan )

	return titan
}

function NpcPilotRunsToAndEmbarksFallingTitan( entity pilot, entity titan )
{
	//wait for it to land
	waitthread WaitTillHotDropComplete( titan )

	if( !IsValid( titan ) )
	    return

	if ( !IsAlive( titan ) )
		return

	if( !IsValid( pilot ) )
		return

	if( !IsAlive( pilot ) )
	    return

	pilot.EndSignal( "OnDestroy" )
	pilot.EndSignal( "OnDeath" )

	//run to the titan
	NPCFollowsNPCModded( pilot, titan )

	//embark titan
	waitthread NpcPilotEmbarksTitan( pilot, titan )
}

entity function NpcPilotCallsInTitan( entity pilot, vector origin, vector angles, bool dontusewarpfall = false )
{
	Assert( !pilot.IsTitan() )
	Assert( IsAlive( pilot ) )
	Assert( !NpcPilotGetPetTitan( pilot ) )

	//reset the next titan callin timer
	NpcResetNextTitanRespawnAvailable( pilot )

	//spawn a titan
	array<string> settingsArray = GetAllowedTitanAISettings()
	bool usewarpfall = false
	bool usedomeshieldwarpfall = false

	settingsArray.extend([ "npc_titan_auto_atlas_ion_prime", "npc_titan_auto_ogre_scorch_prime", "npc_titan_auto_stryder_northstar_prime", "npc_titan_auto_stryder_ronin_prime", "npc_titan_auto_atlas_tone_prime", "npc_titan_auto_ogre_legion_prime" ])
	string titanSettings = settingsArray.getrandom()
	string pilotname = pilot.GetTitle() // Pilot Could Die During Warpfall Which Can Crash The Server
	int pilotteam = pilot.GetTeam()
	if ( RandomInt( 2 ) < 1 && dontusewarpfall == false )
	{
	usewarpfall = true
	}
   if( usewarpfall == false )
   {
	if ( GetMapName().find( "mp_lf_") != null || GetMapName() == "mp_grave" )
	{
	usedomeshieldwarpfall = true
	}
   }
	if( usewarpfall == true )
	{
	NPCPrespawnWarpfallSequence( titanSettings, origin, angles )
	}
	if( usedomeshieldwarpfall == true )
	{
	NPCPrespawnWarpfallSequenceModded( titanSettings, origin, angles )
	}
	string setFile = GetRandomTitanSetFile( titanSettings )
	entity titan = CreateNPCTitan( setFile, pilotteam, origin, angles )
	SetSpawnOption_AISettings( titan, titanSettings )
	DispatchSpawn( titan )
	if( IsValid( pilot ) )
	{
	if( IsAlive( pilot ) )
	NpcPilotSetPetTitan( pilot, titan )
	}

	//call it in
   if ( usewarpfall == false )
   {
	if( usedomeshieldwarpfall == false )
	{
	thread NPCTitanHotdrops( titan, false )
	}
   }
   else
   {
   thread NPCTitanHotdropsWarpfall( titan, true )
   }
	if( usedomeshieldwarpfall == true )
	{
	thread NPCTitanHotdrops( titan, false, "at_hotdrop_drop_2knee_turbo_upgraded" )
	}
	if( IsValid( pilot ) )
	{
	 if( IsAlive( pilot ) )
	 {
	 titan.SetOwner( pilot )
	 NPCFollowsNPCModded( titan, pilot )
	 if( usewarpfall == false )
	 thread TitanStandAfterDropIn( titan, pilot )
	 }
	}
	PilotNotInTitanSet( titan, true )
	int randomtitancamo = RandomIntRange( 0, 160 ) // 159 is all camos
	titan.SetSkin( 2 ) // titan skin has skinIndex of 2
	titan.SetCamo( randomtitancamo ) // set camo to random
	thread AutoTitanLoadout( titan )
	thread MonitorTitanCore( titan )
	if( usewarpfall == false )
	thread ShouldTitanStandOrKneel( titan, pilot )

	//get the titan ready to be embarked
	SetStanceKneel( titan.GetTitanSoul() )
	titan.SetTitle( pilotname + "'s Auto-Titan" )
	UpdateEnemyMemoryFromTeammates( titan )

	return titan
}

string function GetRandomTitanSetFile( string titanSettings )
{
string SetFile = ""
if( titanSettings == "npc_titan_auto_atlas_stickybomb" )
{
SetFile = "titan_atlas_stickybomb"
}
if( titanSettings == "npc_titan_auto_atlas_ion_prime" )
{
SetFile = "titan_atlas_ion_prime"
}
if( titanSettings == "npc_titan_auto_ogre_meteor" )
{
SetFile = "titan_ogre_meteor"
}
if( titanSettings == "npc_titan_auto_ogre_scorch_prime" )
{
SetFile = "titan_ogre_scorch_prime"
}
if( titanSettings == "titan_stryder_sniper" )
{
SetFile = "npc_titan_auto_stryder_sniper"
}
if( titanSettings == "npc_titan_auto_stryder_northstar_prime" )
{
SetFile = "titan_stryder_northstar_prime"
}
if( titanSettings == "npc_titan_auto_stryder_leadwall" )
{
SetFile = "titan_stryder_leadwall"
}
if( titanSettings == "npc_titan_auto_stryder_ronin_prime" )
{
SetFile = "titan_stryder_ronin_prime"
}
if( titanSettings == "npc_titan_auto_atlas_tracker" )
{
SetFile = "titan_atlas_tracker"
}
if( titanSettings == "npc_titan_auto_atlas_tone_prime" )
{
SetFile = "titan_atlas_tone_prime"
}
if( titanSettings == "npc_titan_auto_ogre_minigun" )
{
SetFile = "titan_ogre_minigun"
}
if( titanSettings == "npc_titan_auto_ogre_legion_prime" )
{
SetFile = "titan_ogre_legion_prime"
}
if( titanSettings == "npc_titan_auto_atlas_vanguard" )
{
SetFile = "titan_atlas_vanguard"
}
return SetFile
}

void function ShouldTitanStandOrKneel( entity titan, entity pilot )
{
titan.WaitSignal( "TitanHotDropComplete" )
if( !IsValid( titan ) )
return
if( !IsAlive( titan ) )
return
if( !IsValid( pilot ) )
thread TitanStandUp( titan )
if( !IsAlive( pilot ) )
thread TitanStandUp( titan )
pilot.EndSignal( "OnDeath" )
pilot.EndSignal( "OnDestroy" )
	OnThreadEnd(
		function () : ( titan )
		{
			if ( IsValid( titan ) )
			{
			 if( IsAlive( titan ) )
			 {
			 if( !titan.GetTitanSoul().soul.seatedNpcPilot.isValid && !titan.GetTitanSoul().soul.seatedNpcPilot.titanstanding )
			 thread TitanStandUp( titan )
			 }
			}
		}
	)
WaitForever()
}

void function NPCFollowsNPCModded( entity npc, entity leader ) // Fixed Version Of NPCFollowsNPC
{
thread NPCFollowsNPCModded_thread( npc, leader )
}

void function NPCFollowsNPCModded_thread( entity npc, entity leader )
{
    leader.EndSignal( "OnDeath" )
	leader.EndSignal( "OnDestroy" )
	npc.EndSignal( "OnDeath" )
	npc.EndSignal( "OnDestroy" ) // Do This With The NPC So We Can Stop The Script When The NPC Dies

	OnThreadEnd(
		function () : ( npc )
		{
			if ( IsValid( npc ) )
			{
			 if( IsAlive( npc ) )
			 {
			 npc.DisableBehavior( "Follow" )
			 }
			}
		}
	)

	npc.Signal( "StopHardpointBehavior" )
	int followBehavior = GetDefaultNPCFollowBehavior( npc )
	npc.InitFollowBehavior( leader, followBehavior )
	npc.EnableBehavior( "Follow" )
	WaitForever()
}

function NPCTitanHotdropsWarpfall( entity titan, bool standImmediately, string titanfallAnim = "at_hotdrop_drop_2knee_turbo_upgraded" )
{
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )

	titan.e.isHotDropping = true
	titan.s.bubbleShieldStatus <- 0

	titan.SetEfficientMode( true )
	titan.SetTouchTriggers( false )
	titan.SetAimAssistAllowed( false )

	float impactTime = GetHotDropImpactTime( titan, titanfallAnim )
	vector origin = titan.GetOrigin()
	vector angles = titan.GetAngles()

	#if GRUNTCHATTER_ENABLED
		GruntChatter_TryIncomingSpawn( titan, origin )
	#endif

	#if MP
	TryAnnounceTitanfallWarningToEnemyTeam( titan.GetTeam(), origin )
	#endif

	waitthread PlayersTitanHotdrops( titan, origin, angles, null, titanfallAnim )

	if ( standImmediately )
	{
		SetStanceStand( titan.GetTitanSoul() )
		waitthread PlayAnimGravity( titan, "at_hotdrop_quickstand" )
	}

	titan.SetEfficientMode( false )
	titan.SetTouchTriggers( true )
	titan.SetAimAssistAllowed( true )

	titan.e.isHotDropping = false
	titan.Signal( "TitanHotDropComplete" )

	titan.SetNoTarget( false )

	while( titan.s.bubbleShieldStatus == 1 )
		titan.WaitSignal( "BubbleShieldStatusUpdate" )
}

void function NPCPrespawnWarpfallSequenceModded( string aiSettings, vector spawnOrigin, vector spawnAngle )
{
	string animation = "at_hotdrop_drop_2knee_turbo_upgraded"
//	string settings = GetTitanForPlayer( player ).titanSetFile
	string playerSettings = expect string( Dev_GetAISettingByKeyField_Global( aiSettings, "npc_titan_player_settings" ) )
	asset model = GetPlayerSettingsAssetForClassName( playerSettings, "bodymodel" )
	Attachment warpAttach = GetAttachmentAtTimeFromModel( model, animation, "offset", spawnOrigin, spawnAngle, 0 )

	entity fakeTitan = CreatePropDynamic( model )
	float impactTime = GetHotDropImpactTime( fakeTitan, animation )

	#if SP //MP AI already call DisableTitanfallForLifetimeOfEntityNearOrigin() in SpawnNeutralAI()/SpawnTeamAI() functions. Pretty sure can just remove this for SP too
		thread TemporarilyDisableTitanfallAroundRadius( spawnOrigin, 72, WARPFALL_SOUND_DELAY + WARPFALL_FX_DELAY ) //TODO: Look into getting rid of this. Doesn't play well with DisableTitanfallForLifetimeOfEntityNearOrigin. Only used in Beacon
	#endif

	fakeTitan.Kill_Deprecated_UseDestroyInstead()

	EmitSoundAtPosition( TEAM_UNASSIGNED, spawnOrigin, "Titan_3P_Warpfall_CallIn" )

	wait WARPFALL_SOUND_DELAY + 2.5

	//	"Titan_1P_Warpfall_Start" 			- for first person warp calls, starting right on the button press
	//	"Titan_3P_Warpfall_Start"  			- for any 3P other player or NPC when they call in a warp, starting right on their button press
	EmitSoundAtPosition( TEAM_UNASSIGNED, spawnOrigin, "Titan_3P_Warpfall_Start" )

	PlayFX( TURBO_WARP_FX, warpAttach.position + Vector(0,0,-104), warpAttach.angle )

	wait WARPFALL_FX_DELAY
}

void function RandomPilotName( pilot, int thing = 0, string startthing = "" ) 
{
array<string> possiblenames = file.pilotnames
array<string> unusablenames
array<string> usablenames
foreach( entity ai in GetNPCArray() )
unusablenames.append( ai.GetTitle() )
foreach( string name in possiblenames )
if( !(unusablenames.contains( name )) )
usablenames.append( name )
 if( usablenames.len() <= 0 )
 {
  thing += 1
  startthing = "(" + thing.tostring() + ")"
  RandomPilotName( pilot, thing, startthing )
 }
 else
 pilot.SetTitle( "[AI]" + startthing + usablenames.getrandom() )
}

void function RandomPilotWeapon( entity pilot )
{
TakeWeaponsForArray( pilot, pilot.GetMainWeapons() )
pilot.GiveWeapon( file.pilotweapons.getrandom() )
pilot.GiveWeapon( file.pilotantititanweapons.getrandom() )
}

void function RandomPilotModel( entity pilot )
{
pilot.SetModel( file.pilotmodels.getrandom() )
}

void function OnNPCPilotEnemyChange( entity guy )
{
	if ( !IsAlive( guy ) )
		return

	if ( guy.IsFrozen() )
		return

	entity enemy = guy.GetEnemy()
	if ( !IsAlive( enemy ) )
		return

	array<entity> weapons = guy.GetMainWeapons()
	if ( weapons.len() < 2 )
		return

	entity activeWeapon = guy.GetActiveWeapon()
	if ( !IsValid( activeWeapon ) )
		return

	string activeWeaponName = activeWeapon.GetWeaponClassName()
	bool antiTitanActive = activeWeapon != weapons[0] && !activeWeapon.GetWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required )

	bool isHeavyArmorTarget = enemy.GetArmorType() == ARMOR_TYPE_HEAVY

	string weaponToChange = ""
	if ( isHeavyArmorTarget )
	{
		if ( antiTitanActive )
			return

		foreach ( entity weapon in weapons )
		{
			string className = weapon.GetWeaponClassName()
			if ( activeWeaponName == className )
				continue
			bool isMainWeapon = weapon == weapons[0]
			bool isAntiTitan = !weapon.GetWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required )
			if ( isAntiTitan && !isMainWeapon )
			{
				weaponToChange = className
				break
			}
		}
	}
	else if ( antiTitanActive )
	{
		foreach ( entity weapon in weapons )
		{
			string className = weapon.GetWeaponClassName()
			if ( activeWeaponName == className )
				continue
			bool isMainWeapon = weapon == weapons[0]
			bool isAntiTitan = !weapon.GetWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required )
			if ( isMainWeapon || !isAntiTitan )
			{
				weaponToChange = className
				break
			}
		}
	}
 
	if ( weaponToChange == "" )
		return

		guy.SetActiveWeaponByName( weaponToChange )
}

void function core( entity titan )
{
while( true )
   {
    titan.WaitSignal( "CoreBegin" )
    if( IsValid( titan ) )
    {
    ronincore( titan )
    }
	if( !IsValid( titan ) )
	return
   }
}

void function ronincore( entity titan )
{
    entity meleeWeapon = titan.GetMeleeWeapon()
	if( meleeWeapon.HasMod( "super_charged" ) )
    {
    titan.SetAISettings( "npc_titan_stryder_leadwall_shift_core" )
    titan.SetBehaviorSelector( "behavior_titan_melee_core" )
	}
    titan.WaitSignal( "CoreEnd" )
	if( IsValid( titan ) )
    {
    titan.SetAISettings( "npc_titan_stryder_leadwall" )
	titan.SetBehaviorSelector( "behavior_titan_shotgun" )
	}
}

void function MonitorMonarchShield( entity npc )
{
	entity soul = npc.GetTitanSoul()
	if ( !IsValid( soul ) )
		return

	if ( !soul.soul.seatedNpcPilot.isValid )
	    return
	
	npc.EndSignal( "OnDestroy" )
	npc.EndSignal( "OnDeath" )
	soul.EndSignal( "OnDestroy" )
	soul.EndSignal( "OnDeath" )
	
	while( true )
	{
	WaitFrame()
		entity soul = npc.GetTitanSoul()
	    if ( !IsValid( soul ) )
		return

	    if ( !soul.soul.seatedNpcPilot.isValid )
	    return

		WaitTillTitanCoreCharge( npc )

		if( !IsValid( npc ) )
		return

	    if ( !IsValid( soul ) )
		return

	    if ( !soul.soul.seatedNpcPilot.isValid )
	    return

		if( soul.GetTitanSoulNetInt( "upgradeCount" ) > 2 )
		{
		 if( soul.GetShieldHealth() > soul.GetShieldHealthMax() * 0.1 )
	     {
		 thread MonitorMonarchShield( npc )
		 return
		 }
		}
		
		if( npc.ContextAction_IsBusy() || npc.ContextAction_IsMeleeExecution() )
	    {
		thread MonitorMonarchShield( npc )
		return
		}

			SoulTitanCore_SetNextAvailableTime( soul, 0.0 )
			entity coreEffect = CreateCoreEffect( npc, $"P_titan_core_atlas_blast" )
			EmitSoundOnEntity( npc, "Titan_Monarch_Smart_Core_Activated_3P" )
			soul.SetShieldHealth( soul.GetShieldHealthMax() )
			entity shake = CreateShake( npc.GetOrigin(), 16.0, 5.0, 2.5, 1500.0 )
			shake.SetParent( npc, "CHESTFOCUS" )
			entity weapon = npc.GetOffhandWeapon( OFFHAND_EQUIPMENT )
			if( IsValid( weapon ) )
			{
			thread MonarchUpgrade( weapon )
			wait weapon.GetCoreDuration()
			}
			if( !IsValid( weapon ) )
			wait 2.5
			shake.Destroy()
			coreEffect.Destroy()
	}
}

void function MonitorTitanCore( entity npc )
{
	entity soul = npc.GetTitanSoul()
	if ( !IsValid( soul ) )
		return
	
	soul.EndSignal( "OnDestroy" )
	soul.EndSignal( "OnDeath" )
	npc.EndSignal( "OnDestroy" )
	npc.EndSignal( "OnDeath" )
	
	while( true )
	{
	    SoulTitanCore_SetNextAvailableTime( soul, 0.7 )
		npc.WaitSignal( "CoreBegin" )
		npc.WaitSignal( "CoreEnd" )
	}
}

void function WaitTillTitanCoreCharge( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return

	soul.EndSignal( "OnDestroy" )

	// wait till titan core fully expire first
	while ( IsAlive( titan ) )
	{
		if ( !TitanCoreInUse( titan ) )
			break

		WaitFrame()
	}

	// wait till titan core charge
	while ( IsAlive( titan ) )
	{
		//print( "SoulTitanCore_GetNextAvailableTime( soul ): " + string( SoulTitanCore_GetNextAvailableTime( soul ) ) )
		if ( SoulTitanCore_GetNextAvailableTime( soul ) == 1.0 )
			break

		WaitFrame()
	}
}

void function MonarchUpgrades( entity titan )
{
entity soul = titan.GetTitanSoul()
if( !IsValid( soul ) )
return

GivePassive( soul, ePassives.PAS_VANGUARD_CORE1 )

if ( RandomInt( 100 ) < 50 )
GivePassive( soul, ePassives.PAS_VANGUARD_CORE7 )

if ( !SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE7 ) )
GivePassive( soul, ePassives.PAS_VANGUARD_CORE9 )

GivePassive( soul, ePassives.PAS_VANGUARD_CORE8 )

}

void function MonarchUpgrade( entity weapon )
{
	entity owner = weapon.GetWeaponOwner()
	entity soul = owner.GetTitanSoul()
		int currentUpgradeCount = soul.GetTitanSoulNetInt( "upgradeCount" )
		if ( currentUpgradeCount == 0 )
		{
			if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE1 ) )  // Arc Rounds
			{
				array<entity> weapons = GetPrimaryWeapons( owner )
				if ( weapons.len() > 0 )
				{
					entity primaryWeapon = weapons[0]
					if ( IsValid( primaryWeapon ) )
					{
						array<string> mods = primaryWeapon.GetMods()
						mods.append( "arc_rounds" )
						primaryWeapon.SetMods( mods )
						primaryWeapon.SetWeaponPrimaryClipCount( primaryWeapon.GetWeaponPrimaryClipCount() + 10 )
					}
				}
				if ( owner.IsPlayer() )
				{
					int conversationID = GetConversationIndex( "upgradeTo1" )
					Remote_CallFunction_Replay( owner, "ServerCallback_PlayTitanConversation", conversationID )
					Remote_CallFunction_NonReplay( owner, "ServerCallback_VanguardUpgradeMessage", 1 )
				}
			}
		}
		else if ( currentUpgradeCount == 1 )
		{
			if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE7 ) )  // Multi-Target Missiles
			{
				if ( owner.IsPlayer() )
				{
					array<string> conversations = [ "upgradeTo3", "upgradeToFin" ]
					int conversationID = GetConversationIndex( conversations.getrandom() )
					Remote_CallFunction_Replay( owner, "ServerCallback_PlayTitanConversation", conversationID )
					Remote_CallFunction_NonReplay( owner, "ServerCallback_VanguardUpgradeMessage", 7 )
				}

				entity ordnance = owner.GetOffhandWeapon( OFFHAND_RIGHT )

				owner.TakeWeaponNow( ordnance.GetWeaponClassName() )
				owner.GiveOffhandWeapon( "mp_titanweapon_shoulder_rockets", OFFHAND_RIGHT )
			}
			else if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE9 ) ) //XO-16 Battle Rifle
			{
				array<entity> weapons = GetPrimaryWeapons( owner )
				if ( weapons.len() > 0 )
				{
					entity primaryWeapon = weapons[0]
					if ( IsValid( primaryWeapon ) )
					{
						if ( primaryWeapon.HasMod( "arc_rounds" ) )
						{
							primaryWeapon.RemoveMod( "arc_rounds" )
							array<string> mods = primaryWeapon.GetMods()
							mods.append( "arc_rounds_with_battle_rifle" )
							primaryWeapon.SetMods( mods )
						}
						else
						{
							array<string> mods = primaryWeapon.GetMods()
							mods.append( "battle_rifle" )
							mods.append( "battle_rifle_icon" )
							primaryWeapon.SetMods( mods )
						}
					}
				}

				if ( owner.IsPlayer() )
				{
					array<string> conversations = [ "upgradeTo3", "upgradeToFin" ]
					int conversationID = GetConversationIndex( conversations.getrandom() )
					Remote_CallFunction_Replay( owner, "ServerCallback_PlayTitanConversation", conversationID )
					Remote_CallFunction_NonReplay( owner, "ServerCallback_VanguardUpgradeMessage", 9 )
				}
			}
		}
		else if ( currentUpgradeCount == 2 )
		{
			if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE8 ) ) //Superior Chassis
			{
				if ( owner.IsPlayer() )
				{
					array<string> conversations = [ "upgradeTo3", "upgradeToFin" ]
					int conversationID = GetConversationIndex( conversations.getrandom() )
					Remote_CallFunction_Replay( owner, "ServerCallback_PlayTitanConversation", conversationID )
					Remote_CallFunction_NonReplay( owner, "ServerCallback_VanguardUpgradeMessage", 8 )

					if ( !GetDoomedState( owner ) )
					{
						int missingHealth = owner.GetMaxHealth() - owner.GetHealth()
						array<string> settingMods = owner.GetPlayerSettingsMods()
						settingMods.append( "core_health_upgrade" )
						owner.SetPlayerSettingsWithMods( owner.GetPlayerSettings(), settingMods )
						owner.SetHealth( max( owner.GetMaxHealth() - missingHealth, VANGUARD_CORE8_HEALTH_AMOUNT ) )

						//Hacky Hack - Append core_health_upgrade to setFileMods so that we have a way to check that this upgrade is active.
						soul.soul.titanLoadout.setFileMods.append( "core_health_upgrade" )
					}
					else
					{
						owner.SetHealth( owner.GetMaxHealth() )
					}
				}
				else
				{
				  if ( !GetDoomedState( owner ) )
				  {
					  owner.SetMaxHealth( owner.GetMaxHealth() + VANGUARD_CORE8_HEALTH_AMOUNT )
					  owner.SetHealth( owner.GetHealth() + VANGUARD_CORE8_HEALTH_AMOUNT )
				  }
				}
				entity soul = owner.GetTitanSoul()
				soul.SetPreventCrits( true )
			}
		}
		else
		{
			if ( owner.IsPlayer() )
			{
				int conversationID = GetConversationIndex( "upgradeShieldReplenish" )
				Remote_CallFunction_Replay( owner, "ServerCallback_PlayTitanConversation", conversationID )
			}
		}
		soul.SetTitanSoulNetInt( "upgradeCount", currentUpgradeCount + 1 )
}

void function PilotInTitanSet( entity titan )
{
    if( IsValid( titan ) )
	{
	thread GiveTitanSmokeEveryThirtySeconds( titan )
	thread EmbarkedNPCTitanRodeoCounter( titan )
	string attackerType = GetTitanCharacterName( titan )
	switch ( attackerType )
	    {
		case "ronin":
		                titan.SetAISettings( "npc_titan_stryder_leadwall" )
						titan.SetBehaviorSelector( "behavior_titan_shotgun" )
						thread core( titan )
                        break;
		case "scorch":
		                titan.SetAISettings( "npc_titan_ogre_meteor" )
						titan.SetBehaviorSelector( "behavior_titan_ogre_meteor" )
                        break;
		case "legion":
		                titan.SetAISettings( "npc_titan_ogre_minigun" )
						titan.SetBehaviorSelector( "behavior_titan_ogre_minigun" )
						titan.SetNPCMoveSpeedScale( 1.25 )
			            break;
		case "ion":
		                titan.SetAISettings( "npc_titan_atlas_stickybomb" )
						titan.SetBehaviorSelector( "behavior_titan_long_range" )
                        break;
		case "tone":
		                titan.SetAISettings( "npc_titan_atlas_tracker" )
						titan.SetBehaviorSelector( "behavior_titan_long_range" )
                        break;
		case "vanguard":
		                titan.SetAISettings( "npc_titan_atlas_vanguard" )
						titan.SetBehaviorSelector( "behavior_titan_long_range" )
						thread MonitorMonarchShield( titan )
                        break;
        case "northstar":
		                titan.SetAISettings( "npc_titan_stryder_sniper" )
						titan.SetBehaviorSelector( "behavior_titan_sniper" )
			            break;
		}
	titan.SetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK, false )
	titan.EnableNPCMoveFlag( NPCMF_PREFER_SPRINT )
    array <int> flags 
    flags.extend([ NPC_NO_PAIN, NPC_NO_GESTURE_PAIN, NPC_ALLOW_PATROL, NPC_ALLOW_INVESTIGATE, NPC_IGNORE_FRIENDLY_SOUND ])
    thread OnFlagChanged( titan, flags, false, true, true )
    array <int> disableflags 
    disableflags.extend([ NPC_PAIN_IN_SCRIPTED_ANIM, NPC_ALLOW_FLEE ])
    thread OnFlagChanged( titan, disableflags, true, true, true )
	}
}

void function PilotNotInTitanSet( entity titan, bool firsttime = false )
{
    if( IsValid( titan ) )
	{
	 if( firsttime != true )
	 {
	 string attackerType = GetTitanCharacterName( titan )
	 switch ( attackerType )
	    {
		case "ronin":
		                titan.SetAISettings( "npc_titan_auto_stryder_leadwall" )
                        break;
		case "scorch":
		                titan.SetAISettings( "npc_titan_auto_ogre_meteor" )
                        break;
		case "legion":
		                titan.SetAISettings( "npc_titan_auto_ogre_minigun" )
						titan.SetNPCMoveSpeedScale( 1.0 )
			            break;
		case "ion":
		                titan.SetAISettings( "npc_titan_auto_atlas_stickybomb" )
                        break;
		case "tone":
		                titan.SetAISettings( "npc_titan_auto_atlas_tracker" )
                        break;
		case "vanguard":
		                titan.SetAISettings( "npc_titan_auto_atlas_vanguard" )
                        break;
        case "northstar":
		                titan.SetAISettings( "npc_titan_auto_stryder_sniper" )
			            break;
		}
	 }
	titan.DisableNPCMoveFlag( NPCMF_PREFER_SPRINT )
	titan.DisableNPCFlag( NPC_NO_PAIN | NPC_NO_GESTURE_PAIN | NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_IGNORE_FRIENDLY_SOUND )
	titan.EnableNPCFlag( NPC_PAIN_IN_SCRIPTED_ANIM | NPC_ALLOW_FLEE )
	}
}

void function AutoTitanLoadout( entity titan )
{
    if( IsValid( titan ) )
	{
	TakeWeaponsForArray( titan, titan.GetMainWeapons() )
	titan.TakeOffhandWeapon( OFFHAND_ORDNANCE )
	titan.TakeOffhandWeapon( OFFHAND_SPECIAL )
	titan.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
	titan.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
	titan.TakeOffhandWeapon( OFFHAND_MELEE )
	string attackerType = GetTitanCharacterName( titan )
	switch ( attackerType )
	    {
		case "ronin":
		                titan.GiveWeapon( "mp_titanweapon_leadwall" )
						titan.GiveOffhandWeapon( "mp_titanweapon_arc_wave", OFFHAND_ORDNANCE )
						titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT )
						titan.GiveOffhandWeapon( "mp_titanability_phase_dash", OFFHAND_ANTIRODEO )
						titan.GiveOffhandWeapon( "mp_ability_swordblock", OFFHAND_SPECIAL )
						titan.GiveOffhandWeapon( "melee_titan_sword", OFFHAND_MELEE )
						entity soul = titan.GetTitanSoul()
						if( IsValid( soul ) )
						{
						soul.soul.titanLoadout.titanExecution = "execution_random_3"
						}
                        break;
		case "scorch":
		                titan.GiveWeapon( "mp_titanweapon_meteor" )
						titan.GiveOffhandWeapon( "mp_titanweapon_flame_wall", OFFHAND_ORDNANCE )
						titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT )
						titan.GiveOffhandWeapon( "mp_titanability_slow_trap", OFFHAND_ANTIRODEO )
						titan.GiveOffhandWeapon( "mp_titanweapon_heat_shield", OFFHAND_SPECIAL )
						titan.GiveOffhandWeapon( "melee_titan_punch", OFFHAND_MELEE )
						entity soul = titan.GetTitanSoul()
						if( IsValid( soul ) )
						{
						soul.soul.titanLoadout.titanExecution = "execution_random_1"
						}
                        break;
		case "legion":
		                titan.GiveWeapon( "mp_titanweapon_predator_cannon" )
						titan.GiveOffhandWeapon( "mp_titanability_power_shot", OFFHAND_ORDNANCE )
						titan.GiveOffhandWeapon( "mp_titancore_siege_mode", OFFHAND_EQUIPMENT )
						titan.GiveOffhandWeapon( "mp_titanability_ammo_swap", OFFHAND_ANTIRODEO )
						titan.GiveOffhandWeapon( "mp_titanability_gun_shield", OFFHAND_SPECIAL )
						titan.GiveOffhandWeapon( "melee_titan_punch", OFFHAND_MELEE )
						entity soul = titan.GetTitanSoul()
						if( IsValid( soul ) )
						{
						soul.soul.titanLoadout.titanExecution = "execution_random_5"
						}
			            break;
		case "ion":
		                titan.GiveWeapon( "mp_titanweapon_particle_accelerator" )
						titan.GiveOffhandWeapon( "mp_titanweapon_laser_lite", OFFHAND_ORDNANCE )
						titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT )
						titan.GiveOffhandWeapon( "mp_titanability_laser_trip", OFFHAND_ANTIRODEO )
						titan.GiveOffhandWeapon( "mp_titanweapon_vortex_shield", OFFHAND_SPECIAL )
						titan.GiveOffhandWeapon( "melee_titan_punch", OFFHAND_MELEE )
						entity soul = titan.GetTitanSoul()
						if( IsValid( soul ) )
						{
						soul.soul.titanLoadout.titanExecution = "execution_ion"
						}
                        break;
		case "tone":
		                titan.GiveWeapon( "mp_titanweapon_sticky_40mm" )
						titan.GiveOffhandWeapon( "mp_titanweapon_tracker_rockets", OFFHAND_ORDNANCE )
						titan.GiveOffhandWeapon( "mp_titancore_salvo_core", OFFHAND_EQUIPMENT )
						titan.GiveOffhandWeapon( "mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO )
						titan.GiveOffhandWeapon( "mp_titanability_particle_wall", OFFHAND_SPECIAL )
						titan.GiveOffhandWeapon( "melee_titan_punch", OFFHAND_MELEE )
						entity soul = titan.GetTitanSoul()
						if( IsValid( soul ) )
						{
						soul.soul.titanLoadout.titanExecution = "execution_random_4"
						}
                        break;
		case "vanguard":
		                titan.GiveWeapon( "mp_titanweapon_xo16_vanguard" )
						titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE )
						titan.GiveOffhandWeapon( "mp_titancore_upgrade", OFFHAND_EQUIPMENT )
						titan.GiveOffhandWeapon( "mp_titanability_rearm", OFFHAND_ANTIRODEO )
						titan.GiveOffhandWeapon( "mp_titanweapon_stun_laser", OFFHAND_SPECIAL )
						titan.GiveOffhandWeapon( "melee_titan_punch", OFFHAND_MELEE )
						thread MonarchUpgrades( titan )
						entity soul = titan.GetTitanSoul()
						if( IsValid( soul ) )
						{
						soul.soul.titanLoadout.titanExecution = "execution_vanguard"
						 if ( RandomInt( 100 ) < 50 )
						 {
						 GivePassive( soul, ePassives.PAS_VANGUARD_COREMETER )
						 soul.soul.titanLoadout.titanExecution = "execution_vanguard_kit"
						 }
						 if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_COREMETER ) && RandomInt( 100 ) < 50 )
						 GivePassive( soul, ePassives.PAS_VANGUARD_DOOM )
						}
                        break;
        case "northstar":
		                titan.GiveWeapon( "mp_titanweapon_sniper" )
						titan.GiveOffhandWeapon( "mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE )
						titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT )
						titan.GiveOffhandWeapon( "mp_titanability_hover", OFFHAND_ANTIRODEO )
						titan.GiveOffhandWeapon( "mp_titanability_tether_trap", OFFHAND_SPECIAL )
						titan.GiveOffhandWeapon( "melee_titan_punch", OFFHAND_MELEE )
						entity soul = titan.GetTitanSoul()
						if( IsValid( soul ) )
						{
						soul.soul.titanLoadout.titanExecution = "execution_random_2"
						}
			            break;
		}
	if(GetCurrentPlaylistVarInt("aegis_upgrades", 0) == 1)
	{
	titan.SetMaxHealth( titan.GetMaxHealth() + 2500 )
	titan.SetHealth( titan.GetMaxHealth() )
	}
	bool hasnucleareject = false
	 if ( RandomInt( 100 ) < 50 )
	 {
	 hasnucleareject = true
	 NPC_SetNuclearPayload( titan )
	 }
	 if ( hasnucleareject == false && RandomInt( 100 ) < 50 )
	 GiveTitanAutoEject( titan )
	}
}

void function TitanStandAfterDropIn( entity titan, entity pilot )
{
wait 23
if( IsValid( titan ) && IsValid( pilot ) )
{
if( IsAlive( titan ) && IsAlive( pilot ) && (!(titan in file.titanisbeingembarked) || file.titanisbeingembarked[titan] == false) )
{
titan.GetTitanSoul().soul.seatedNpcPilot.titanstanding = true
thread TitanStandUp( titan )
}
}
}

void function __TitanKneelOrStandAfterDropin( entity titan, entity pilot )
{
	Assert( IsAlive( titan ) )
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )

	titan.WaitSignal( "TitanHotDropComplete" )

	if ( IsAlive( pilot ) )
		thread PlayAnimGravity( titan, "at_MP_embark_idle" )
	//else the titan will automatically stand up
}

/************************************************************************************************\

 ######  ##      ## #### ########  ######  ##     ##
##    ## ##  ##  ##  ##     ##    ##    ## ##     ##
##       ##  ##  ##  ##     ##    ##       ##     ##
 ######  ##  ##  ##  ##     ##    ##       #########
      ## ##  ##  ##  ##     ##    ##       ##     ##
##    ## ##  ##  ##  ##     ##    ##    ## ##     ##
 ######   ###  ###  ####    ##     ######  ##     ##

\************************************************************************************************/
function NpcPilotEmbarksTitan( entity pilot, entity titan )
{
	Assert( IsAlive( pilot ) )
	Assert( IsAlive( titan ) )
	Assert( !pilot.IsTitan() )
	Assert( titan.IsTitan() )

	titan.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDeath" )

	local titanSubClass = GetSoulTitanSubClass( titan.GetTitanSoul() )
	local embarkSet = FindBestEmbark( pilot, titan )

	while ( embarkSet == null )
	{
		WaitFrame()
		embarkSet = FindBestEmbark( pilot, titan )
	}

	FirstPersonSequenceStruct sequence
	sequence.attachment = "hijack"
	sequence.useAnimatedRefAttachment = expect bool ( embarkSet.action.useAnimatedRefAttachment )
	sequence.blendTime = 0.5
	sequence.thirdPersonAnim = GetAnimFromAlias( titanSubClass, embarkSet.animSet.thirdPersonKneelingAlias )
	local titanAnim = embarkSet.animSet.titanKneelingAnim
	if ( titan.GetTitanSoul().GetStance() > STANCE_STANDING )
	{
	sequence.thirdPersonAnim = GetAnimFromAlias( titanSubClass, embarkSet.animSet.thirdPersonStandingAlias )
	titanAnim = embarkSet.animSet.titanStandingAnim
	}

	if ( IsCloaked( pilot ) )
		pilot.SetCloakDuration( 0, 0, 1.5 )

	if( pilot.IsInvulnerable() )
	titan.SetInvulnerable()
	pilot.SetInvulnerable()
	pilot.Anim_Stop()
	thread FirstPersonSequence( sequence, pilot, titan )
	array <int> nopain
	nopain.append( NPC_NO_PAIN )
	thread OnFlagChanged( titan, nopain, false, true, false )
	pilot.EnableNPCFlag( NPC_IGNORE_ALL )
	file.titanisbeingembarked[titan] <- true
	waitthread PlayAnimGravity( titan, titanAnim )
	SetStanceStand( titan.GetTitanSoul() )
	NpcPilotBecomesTitan( pilot, titan )
}

entity function NpcPilotDisembarksTitan( entity titan )
{
	Assert( titan.IsTitan() )
	Assert( TitanHasNpcPilot( titan ) )

	entity pilot = NpcTitanBecomesPilot( titan )
	Assert( !pilot.IsTitan() )

	NpcPilotSetPetTitan( pilot, titan )

	thread __NpcPilotDisembarksTitan( pilot, titan )

	return pilot
}

function __NpcPilotDisembarksTitan( pilot, titan )
{
	expect entity( pilot )
	expect entity( titan )

	//titan.ContextAction_SetBusy()
	//pilot.ContextAction_SetBusy()

	if ( pilot.GetTitle() != "" )
	{
		titan.SetTitle( pilot.GetTitle() + "'s Auto-Titan" )
	}

	local isInvulnerable = pilot.IsInvulnerable()
	//pilot.SetInvulnerable()
	//titan.SetInvulnerable()

	local pilot3pAnim, pilot3pAudio, titanDisembarkAnim
	local titanSubClass = GetSoulTitanSubClass( titan.GetTitanSoul() )
	local standing = titan.GetTitanSoul().GetStance() >= STANCE_STANDING // STANCE_STANDING = 2, STANCE_STAND = 3

	if ( standing )
	{
		titanDisembarkAnim = "at_dismount_stand"
		pilot3pAnim = "pt_dismount_" + titanSubClass + "_stand"
		pilot3pAudio = titanSubClass + "_Disembark_Standing_3P"
	}
	else
	{
		titanDisembarkAnim = "at_dismount_crouch"
		pilot3pAnim = "pt_dismount_" + titanSubClass + "_crouch"
		pilot3pAudio = titanSubClass + "_Disembark_Kneeling_3P"
	}

//	pilot.SetParent( titan, "hijack" )
	EmitSoundOnEntity( titan, pilot3pAudio )
	thread PlayAnim( titan, titanDisembarkAnim )
	waitthread PlayAnim( pilot, pilot3pAnim, titan, "hijack" )

	//pilot.ClearParent()
	//titan.ContextAction_ClearBusy()
	//pilot.ContextAction_ClearBusy()
	if ( !isInvulnerable )
		//pilot.ClearInvulnerable()
	//titan.ClearInvulnerable()

	if ( !standing )
		SetStanceKneel( titan.GetTitanSoul() )
}

void function NpcPilotBecomesTitan( entity pilot, entity titan )
{
	Assert( IsAlive( pilot ) )
	Assert( IsAlive( titan ) )
	Assert( IsGrunt( pilot ) || IsPilotElite( pilot ) )
	Assert( titan.IsTitan() )

	array <entity> weapons = pilot.GetMainWeapons()
	array <string> weaponNames
	foreach( entity weapon in weapons )
	{
	weaponNames.append( weapon.GetWeaponClassName() )
	}
	entity titanSoul = titan.GetTitanSoul()

	titanSoul.soul.seatedNpcPilot.isValid				= true

	//titanSoul.soul.seatedNpcPilot.team 					= pilot.GetTeam()
	titanSoul.soul.seatedNpcPilot.weapon 				= weaponNames

	titanSoul.soul.seatedNpcPilot.modelAsset 			= pilot.GetModelName()
	titanSoul.soul.seatedNpcPilot.title 				= pilot.GetTitle()

	// removing this, hard to control
	//titanSoul.soul.seatedNpcPilot.isInvulnerable		= pilot.IsInvulnerable()


	// respawn missing settings saving
	//titanSoul.soul.seatedNpcPilot.spawnflags			= int( pilot.kv.spawnflags )
	titanSoul.soul.seatedNpcPilot.accuracy				= float( pilot.kv.AccuracyMultiplier )
	titanSoul.soul.seatedNpcPilot.proficiency			= float( pilot.kv.WeaponProficiency )
	//titanSoul.soul.seatedNpcPilot.physDamageScale		= float( pilot.kv.physDamageScale )

	titan.SetTitle( titanSoul.soul.seatedNpcPilot.title )

	// vanilla missing, adding this behavior for a fix
	// bubble can be destroyed properly by SetStanceStand( titan.GetTitanSoul() ) in NpcPilotEmbarksTitan()
	// no need to use this function
	//thread DelayedDestroyBubble( titan )
	thread PilotInTitanSet( titan )
	titan.kv.WeaponProficiency = titanSoul.soul.seatedNpcPilot.proficiency
	titan.kv.AccuracyMultiplier = titanSoul.soul.seatedNpcPilot.accuracy
	ScriptCallback_OnNpcPilotBecomesTitan( pilot, titan )
	pilot.Destroy()
}

void function EjectWhenDoomed( entity titan, var damageInfo )
{
thread EjectWhenDoomed_thread( titan )
}

void function EjectWhenDoomed_thread( entity titan )
{
if ( titan.IsPlayer() || !titan.IsTitan() )
    return
bool shouldEjectTitan = false
titan.EndSignal( "OnDestroy" )
titan.EndSignal( "OnDeath" )
if( !HasSoul( titan ) )
    return
entity soul = titan.GetTitanSoul()
if( !IsValid( soul ) )
    return
soul.EndSignal( "OnDestroy" )
soul.EndSignal( "OnDeath" )
wait 1.0 
   while( soul.IsDoomed() && soul.soul.seatedNpcPilot.isValid )
   {
	    if ( !(titan in file.autoeject && file.autoeject[titan] == true) )
	        wait 0.2
        float ejectRequiredDoomedHealth = 1250
		int health = titan.GetHealth()
		int shieldHealth = soul.GetShieldHealth()
		int maxHealth = titan.GetMaxHealth()
		int ShieldHealth = health + shieldHealth
		entity enemy = titan.GetEnemy()
		if ( ShieldHealth <= ejectRequiredDoomedHealth )
			shouldEjectTitan = true 
		if ( IsAlive( enemy ) && enemy.IsTitan() )
		{
			bool horizontallyClose = Distance2D( titan.GetOrigin(), enemy.GetOrigin() ) < 630
			bool enemyIsEjecting = HasSoul( enemy ) && enemy.GetTitanSoul().IsEjecting()
			if ( !enemyIsEjecting && horizontallyClose && !enemy.ContextAction_IsMeleeExecution() )
				shouldEjectTitan = true
		}
		if ( shouldEjectTitan || (titan in file.autoeject && file.autoeject[titan] == true) )
		{
			if ( !titan.IsInvulnerable() || (titan in file.autoeject && file.autoeject[titan] == true) )
			{
				thread TitanEjectPlayerForNPCs( titan )
				return
			}
		}
   }
}

entity function NpcTitanBecomesPilot( entity titan )
{
	Assert( IsValid( titan ) )
	Assert( titan.IsTitan() )

	entity titanSoul = titan.GetTitanSoul()
	if( !IsValid( titanSoul ) ) // defensive fix for titan.Destroy() situations
		return
	titanSoul.soul.seatedNpcPilot.isValid = false

	array <string> weapon 	= titanSoul.soul.seatedNpcPilot.weapon
	asset model 			= titanSoul.soul.seatedNpcPilot.modelAsset
	string title 			= titanSoul.soul.seatedNpcPilot.title
	//int team 				= titanSoul.soul.seatedNpcPilot.team
	int team 				= titan.GetTeam()
	vector origin 			= titan.GetOrigin()
	float angles 		    = titan.GetAngles().z
	float proficiency 		= titanSoul.soul.seatedNpcPilot.proficiency
	float accuracy 			= titanSoul.soul.seatedNpcPilot.accuracy

	entity pilot = CreateEntity( "npc_pilot_elite" )
	pilot.SetOrigin( origin )
	SetTeam( pilot, team )

	// modified here: to make npc spawn longer hardcoded
	//SetSpawnOption_Weapon( pilot, weapon )
	DispatchSpawn( pilot )
	thread PilotMiniMap( pilot )
	thread PilotSpeedFlagsHPAndBehavior( pilot )
	thread NpcPilotCallTitanThink( pilot )
	// hardcoded
	pilot.kv.WeaponProficiency = proficiency
	pilot.kv.AccuracyMultiplier = accuracy
	titan.kv.WeaponProficiency = eWeaponProficiency.AVERAGE
	titan.kv.AccuracyMultiplier = 1.0
	if( title != "" )
	pilot.SetTitle( title )
	else
	RandomPilotName( pilot )
	titan.SetTitle( pilot.GetTitle() + "'s Auto-Titan" )
	if( file.pilotmodels.contains( model ) )
	pilot.SetModel( model ) // this is a hack, trying to avoid having a model spawn option because its easy to abuse
	else
	RandomPilotModel( pilot )
	TakeWeaponsForArray( pilot, pilot.GetMainWeapons() )
	bool gaveweapon = false
	foreach( string newweapons in weapon )
	{
	pilot.GiveWeapon( newweapons )
	gaveweapon = true
	}
	if( gaveweapon == false )
	RandomPilotWeapon( pilot )
	
	// these setup should be moved to callbacks, don't handle in this file
	//pilot.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_FLEE ) // this one is hardcoded, can change it through callbacks
	//Highlight_SetEnemyHighlight( pilot, "enemy_player" )

	//NpcResetNextTitanRespawnAvailable( pilot )

	//pilot.kv.max_health 			= titanSoul.soul.seatedNpcPilot.health
	//pilot.kv.health 				= titanSoul.soul.seatedNpcPilot.health

	// respawn missing settings saving
	//pilot.kv.spawnflags 			= titanSoul.soul.seatedNpcPilot.spawnflags
	//pilot.kv.AccuracyMultiplier 	= titanSoul.soul.seatedNpcPilot.accuracy
	//pilot.kv.physDamageScale 		= titanSoul.soul.seatedNpcPilot.physDamageScale

	// never make pilot invulnerable in this section
	// because SetInvulnerable() can stack, and can make pilot become invulnerable forever
	//if ( titanSoul.soul.seatedNpcPilot.isInvulnerable )
	//	pilot.SetInvulnerable()

	titan.SetOwner( pilot )
	NPCFollowsNPCModded( titan, pilot )

	// respawn missing
	NpcPilotSetPetTitan( pilot, titan ) // should always setup pet titan on titan transfer
	thread PilotNotInTitanSet( titan )

	UpdateEnemyMemoryFromTeammates( pilot )

	ScriptCallback_OnNpcTitanBecomesPilot( pilot, titan )

	return pilot
}

bool function TitanHasNpcPilot( entity titan )
{
	Assert( titan.IsTitan() )

	entity titanSoul = titan.GetTitanSoul()
	if ( !IsValid( titanSoul ) )
		return false

	if ( !titanSoul.soul.seatedNpcPilot.isValid )
		return false

	return true
}

entity function NpcPilotGetPetTitan( entity pilot )
{
	Assert( !pilot.IsTitan() )
	Assert( "petTitan" in pilot.s )

	if ( !IsAlive( expect entity( pilot.s.petTitan ) ) )
		return null

	Assert( pilot.s.petTitan.IsTitan() )
	return expect entity( pilot.s.petTitan )
}

void function NpcPilotSetPetTitan( entity pilot, entity titan )
{
	Assert( !pilot.IsTitan() )
	Assert( titan.IsTitan() )
	Assert( "petTitan" in pilot.s )

	pilot.s.petTitan = titan
	pilot.Signal( "PetTitanUpdated" )
}

function __TitanStanceThink( entity pilot, entity titan )
{
	if ( !IsAlive( titan ) )
		return

	if ( titan.GetTitanSoul().IsDoomed() )
		return

	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )
	titan.EndSignal( "NpcPilotBecomesTitan" )

	WaittillAnimDone( titan ) //wait for disembark anim

	// kneel in certain circumstances
	while ( IsAlive( pilot ) )
	{
		if ( !ChangedStance( titan ) )
			waitthread TitanWaitsToChangeStance_or_PilotDeath( pilot, titan )
	}

	if ( titan.GetTitanSoul().GetStance() < STANCE_STANDING )
	{
		while ( !TitanCanStand( titan ) )
			wait 2

		TitanStandUp( titan )
	}
}

function TitanWaitsToChangeStance_or_PilotDeath( pilot, titan )
{
	pilot.EndSignal( "OnDeath" )
	pilot.EndSignal( "OnDestroy" )

	TitanWaitsToChangeStance( titan )
}

/************************************************************************************************\

########  #######   #######  ##        ######
   ##    ##     ## ##     ## ##       ##    ##
   ##    ##     ## ##     ## ##       ##
   ##    ##     ## ##     ## ##        ######
   ##    ##     ## ##     ## ##             ##
   ##    ##     ## ##     ## ##       ##    ##
   ##     #######   #######  ########  ######

\************************************************************************************************/

function __WaitforTitanCallinReady( entity pilot )
{
	pilot.EndSignal( "OnDeath" )
	pilot.EndSignal( "OnDestroy" )

	//HACK TODO: handle eTitanAvailability.Default vs custom and none, AND ALSO make a way to kill this thread
		//float waittheydontloveyoulikeiloveyou = RandomFloatRange( NPC_NEXT_TITANTIME_MIN, NPC_NEXT_TITANTIME_MAX )
		//wait waittheydontloveyoulikeiloveyou // Removed
		while( true )
		{
		 WaitFrame()
		 if ( pilot in file.titanready ) // If Pilot Isn't In titanready The Server Crashes
		 {
          if( file.titanready[ pilot ] == 10 )
		  return
		 }
		}
}

function __TitanKneelsForPilot( pilot, titan )
{
	expect entity( pilot )
	expect entity( titan )

	pilot.EndSignal( "OnDeath" )
	pilot.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function () : ( pilot, titan )
		{
			if ( !IsAlive( titan ) )
				return

			SetStanceStand( titan.GetTitanSoul() )

			//the pilot never made it to embark - lets stand our titan up so he can fight
			if ( !IsAlive( pilot ) )
			{
				thread PlayAnimGravity( titan, "at_hotdrop_quickstand" )
				HideName( titan )
				//titan.ContextAction_ClearBusy()
			}
		}
	)

	if ( !titan.ContextAction_IsBusy() ) //might be set from kneeling
		//titan.ContextAction_SetBusy()
	SetStanceKneel( titan.GetTitanSoul() )

	waitthread PlayAnimGravity( titan, "at_MP_stand2knee_straight" )
	waitthread PlayAnim( titan, "at_MP_embark_idle" )
}

bool function ShouldCalloutEjection( entity player, vector titanOrigin, entity titan )
{
	if ( DistanceSqr( titanOrigin, titan.GetOrigin() ) < 2000 * 2000 )
		return true

	// have they hit each other recently? To catch LTS sniper war ejections
	if ( WasRecentlyHitByEntity( player, titan, 6.0 ) )
		return true

	if ( WasRecentlyHitByEntity( titan, player, 6.0 ) )
		return true

	return false
}

function TitanEjectVO( entity player, vector titanOrigin )
{
	array<entity> titans = GetTitanArray()
	int team = player.GetTeam()
	int voEnum

	foreach ( titan in titans )
	{
		if ( !titan.IsPlayer() )
			continue
		if ( titan == player )
			continue

		if ( team == titan.GetTeam() )
		{
			if ( DistanceSqr( titanOrigin, titan.GetOrigin() ) > 2000 * 2000 )
				return

			voEnum = eTitanVO.FRIENDLY_EJECTED
		}
		else
		{
			if ( !ShouldCalloutEjection( player, titanOrigin, titan ) )
				return

			voEnum = eTitanVO.ENEMY_EJECTED
		}

		Remote_CallFunction_Replay( titan, "SCB_TitanDialogue", voEnum )
	}
}

TitanEjectDamage function GetSoulEjectDamageOverride( entity soul )
{
	TitanEjectDamage defaultStruct
		return defaultStruct
}

function TitanSkipsDeathOnEject( entity titan )
{
	entity soul = titan.GetTitanSoul()
	soul.soul.diesOnEject = false
}

function ClearEjectInvulnerability( entity player )
{
	if ( !IsValid( player ) )
		return

	player.EndSignal( "OnDeath" )

	OnThreadEnd(
		function () : (player)
		{
			if ( IsValid( player ) )
				player.ClearInvulnerable()
		}
	)

	wait 0.35
}

function LookAtEachOther( entity rider, entity player )
{
	rider.EndSignal( "OnDeath" )
	player.EndSignal( "OnDeath" )

	float endTime = Time() + 0.45

	for ( ;; )
	{
		vector org1 = rider.GetOrigin()
		vector org2 = player.GetOrigin()
		vector vec1 = org2 - org1
		vector angles1 = VectorToAngles( vec1 )
		vector vec2 = org1 - org2
		vector angles2 = VectorToAngles( vec2 )

		angles1.x = 0
		angles2.x = 0
		if ( rider.GetParent() == null )
			rider.SetAngles( angles1 )
		if ( player.GetParent() == null )
			player.SetAngles( angles2 )

		if ( Time() >= endTime )
			return

		WaitFrame()
	}
}

function EjectFlightTracker( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "EjectLand" )
	player.EndSignal( "RodeoStarted" )

	OnThreadEnd(
		function () : (player)
		{
			player.p.pilotEjecting = false
			player.p.pilotEjectEndTime = Time()
		}
	)

	player.p.pilotEjecting = true
	player.p.pilotEjectStartTime = Time()

	wait 0.1
	for ( ;; )
	{
		if ( player.IsOnGround() )
			player.Signal("EjectLand")

		wait 0.1
	}
}

function TitanNonSolidTemp( entity titan )
{
	if ( !EntityInSolid( titan ) )
		return

	local collisionGroup = titan.kv.CollisionGroup
	
	// Blocks bullets, projectiles but not players and not AI
	titan.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS
	
	titan.EndSignal( "OnDeath" )

	while( EntityInSolid( titan ) )
	{
		wait 0.1
	}

	titan.kv.collisionGroup = collisionGroup
}

TitanNukeDamage function GetSoulNukeDamageOverride( entity soul )
{
	TitanNukeDamage defaultStruct
		return defaultStruct
}

function ClearNuclearBlueSunEffect( e )
{
	foreach ( fx in e.nukeFX )
	{
		if ( IsValid( fx ) )
			fx.Kill_Deprecated_UseDestroyInstead()
	}
	e.nukeFX.clear()
	e.needToClearNukeFX = false
}

void function DelayedCleanUpNukeFX( entity titan, array<entity> nukeFXToCleanUp )
{
	titan.WaitSignal( "OnDestroy" )
	foreach ( entity nukeFX in nukeFXToCleanUp )
	{
		if ( IsValid( nukeFX ) )
			EffectStop( nukeFX )
	}
}

function NuclearCoreExplosionChainReaction( vector origin, e )
{
	int explosions
	local innerRadius
	float time
	bool IsNPC

	local heavyArmorDamage = 2500
	local normalDamage = 75

	switch ( e.nuclearPayload )
	{
		case 4:
			// npc nuke: the idea is to be the same as the regular nuke - but with less explosion calls
			explosions = 3
			innerRadius = 350
			time = 1.5 //1 is the regular nuke time - but we won't be adding an extra explosion and we want 3 explosions over 1s. This will mathematically give us that.
			IsNPC = true

			local fraction = 10.0 / explosions //10 is the regular nuke number
			heavyArmorDamage = heavyArmorDamage * fraction
			normalDamage = normalDamage * fraction
			break

		case 3:
			// super nuke: PAS_NUCLEAR_CORE + PAS_BUILD_UP_NUCLEAR_CORE
			explosions = 20
			innerRadius = 350
			time = 1.7
			IsNPC = false
			break

		case 2:
			// super nuke: PAS_NUCLEAR_CORE
			explosions = 15
			innerRadius = 350
			time = 1.4
			IsNPC = false
			break

		case 1:
			// regular nuke: PAS_BUILD_UP_NUCLEAR_CORE
			explosions = 10
			innerRadius = 350
			time = 1.0
			IsNPC = false
			break

		default:
			Assert( 0, "e.nuclearPayload value: " + e.nuclearPayload + " not accounted for." )
			break
	}

	float waitPerExplosion = time / explosions

	ClearNuclearBlueSunEffect( e )

	// modified here: needs clean up fx so it don't show again after watching replay
	array<entity> nukeFXToCleanUp

	if ( IsValid( e.player ) )
	{
		// modified here: all these fx should never hibernate on client-side...
		//thread __CreateFxInternal( TITAN_NUCLEAR_CORE_FX_1P, null, "", origin, Vector(0,RandomInt(360),0), C_PLAYFX_SINGLE, null, 1, expect entity( e.player ) )
		//thread __CreateFxInternal( TITAN_NUCLEAR_CORE_FX_3P, null, "", origin + Vector( 0, 0, -100 ), Vector(0,RandomInt(360),0), C_PLAYFX_SINGLE, null, 6, expect entity( e.player ) )
		entity nukeFX1p = __CreateFxInternal( TITAN_NUCLEAR_CORE_FX_1P, null, "", origin, Vector(0,RandomInt(360),0), C_PLAYFX_SINGLE, null, 1, expect entity( e.player ) )
		nukeFX1p.DisableHibernation()
		nukeFXToCleanUp.append( nukeFX1p )
		entity nukeFX3p = __CreateFxInternal( TITAN_NUCLEAR_CORE_FX_3P, null, "", origin + Vector( 0, 0, -100 ), Vector(0,RandomInt(360),0), C_PLAYFX_SINGLE, null, 6, expect entity( e.player ) )
		nukeFX3p.DisableHibernation()
		nukeFXToCleanUp.append( nukeFX3p )
	}
	else
	{
		// modified here: all these fx should never hibernate on client-side...
		//PlayFX( TITAN_NUCLEAR_CORE_FX_3P, origin + Vector( 0, 0, -100 ), Vector(0,RandomInt(360),0) )
		entity nukeFX = PlayFX( TITAN_NUCLEAR_CORE_FX_3P, origin + Vector( 0, 0, -100 ), Vector(0,RandomInt(360),0) )
		nukeFX.DisableHibernation()
		nukeFXToCleanUp.append( nukeFX )
	}

	// modified settings override: nuke damage
	bool hasNukeDamageOverride = false
	entity titan = expect entity( e.titan )
	entity soul
	if ( IsValid( titan ) && titan.IsTitan() )
		soul = titan.GetTitanSoul()
	// do nuke cleanup after we got titan entity
	thread DelayedCleanUpNukeFX( titan, nukeFXToCleanUp )
	// we cache all the stuffs here because titan's gonna be destroyed soon
	TitanNukeDamage nukeDamageStruct
	/*
	if ( IsValid( soul ) ) // nuke damage effect override
	{
		hasNukeDamageOverride = true

		nukeDamageStruct = GetSoulNukeDamageOverride( soul )
		explosions = nukeDamageStruct.count
		time = nukeDamageStruct.duration
		waitPerExplosion = time / explosions
	}
	*/
	//

	// modified here: allow us delay titan's destroy
	bool freezeDuringNuke = true

	// if we kill the titan after nuke, should set up endsignal so we don't damage entity unexpectly
	if ( freezeDuringNuke )
	{
		titan.EndSignal( "OnDestroy" )

		// setup fake-death entity
		titan.SetNoTarget( true )
		titan.SetEfficientMode( true )
		titan.SetTouchTriggers( false )
		titan.SetAimAssistAllowed( false )
		titan.SetInvulnerable()
		titan.NotSolid()
		titan.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY // this one hides model lights and stuffs, bit nicer
		HideName( titan )

		// wait for next frame before freezing, so titan can actually be dead
		//thread DelayedFreezeTitan( titan )
	}

	// debug
	//print( "explosions: " + string( explosions ) )
	//print( "time: " + string( time ) )
	//print( "waitPerExplosion: " + string( waitPerExplosion ) )

	// vanilla hardcode turns to settings: we do this extra explosion when explosion count higher than 10
	// one extra explosion that does damage to physics entities at smaller radius
	//if ( !IsNPC )
	//	explosions += 1
	bool doPhysicsEntityDamage = false
	if ( explosions >= 10 )
	{
		explosions += 1
		doPhysicsEntityDamage = true
	}

	local outerRadius

	local baseNormalDamage 		= normalDamage
	local baseHeavyArmorDamage 	= heavyArmorDamage
	local baseInnerRadius 		= innerRadius
	local baseOuterRadius 		= outerRadius

	// all damage must have an inflictor currently
	entity inflictor = CreateEntity( "script_ref" )
	inflictor.SetOrigin( origin )
	inflictor.kv.spawnflags = SF_INFOTARGET_ALWAYS_TRANSMIT_TO_CLIENT
	DispatchSpawn( inflictor )

	OnThreadEnd(
		function() : ( inflictor )
		{
			if ( IsValid( inflictor ) )
				inflictor.Destroy()
		}
	)

	for ( int i = 0; i < explosions; i++ )
	{
		local normalDamage 		= baseNormalDamage
		local heavyArmorDamage 	= baseHeavyArmorDamage
		local innerRadius 		= baseInnerRadius
		local outerRadius 		= baseOuterRadius

		// vanilla hardcode turns to settings: we do this extra explosion when explosion count higher than 10
		//if ( i == 0 && !IsNPC )
		if ( i == 0 && doPhysicsEntityDamage )
		{
			normalDamage = 75
			heavyArmorDamage = 0
			outerRadius = 600
		}
		else
		{
			outerRadius = 750
		}

		entity explosionOwner = GetExplosionOwner( e )

		if ( outerRadius < innerRadius )
			outerRadius = innerRadius

		// modified settings override: nuke damage
		if ( hasNukeDamageOverride ) // nuke damage effect override
		{
			// extra explosion that damages physics entity in smaller radius
			if ( i == 0 && doPhysicsEntityDamage )
			{
				normalDamage = nukeDamageStruct.damage
				heavyArmorDamage = 0
				innerRadius = nukeDamageStruct.innerRadius
				outerRadius = maxint( innerRadius, int( nukeDamageStruct.outerRadius * 0.8 ) ) // should never be lower than inner radius
			}
			else // following explosions
			{
				normalDamage = nukeDamageStruct.damage
				heavyArmorDamage = nukeDamageStruct.damageHeavyArmor
				innerRadius = nukeDamageStruct.innerRadius
				outerRadius = nukeDamageStruct.outerRadius
			}

			// we use RadiusDamage because it contains more modifiable stuffs
			RadiusDamage( 
				origin,								// origin
				explosionOwner,						// owner
				inflictor,							// inflictor
				normalDamage,						// normal damage
				heavyArmorDamage,					// heavy armor damage
				innerRadius,						// inner radius
				outerRadius,						// outer radius
				nukeDamageStruct.explosionFlags,	// flags
				0,									// distanceFromAttacker
				nukeDamageStruct.explosionForce,	// explosionForce
				nukeDamageStruct.damageFlags,		// scriptDamageFlags
				nukeDamageStruct.damageSourceId		// scriptDamageSourceIdentifier
			)
		}
		else // vanilla behavior
		{
			RadiusDamage_DamageDef( damagedef_nuclear_core,
				origin,								// origin
				explosionOwner,						// owner
				inflictor,							// inflictor
				normalDamage,						// normal damage
				heavyArmorDamage,					// heavy armor damage
				innerRadius,						// inner radius
				outerRadius,						// outer radius
				0 )									// dist from attacker
		}

		// debug
		//print( "normalDamage: " + string( normalDamage ) )
		//print( "heavyArmorDamage: " + string( heavyArmorDamage ) )
		//print( "innerRadius: " + string( innerRadius ) )
		//print( "outerRadius: " + string( outerRadius ) )

		wait waitPerExplosion
	}

	// modified here: destroy titan AFTER full nuke is done
	WaitFrame() // wait for last damage to go through
	if ( freezeDuringNuke && IsValid( titan ) )
	{
		if ( titan.IsFrozen() )
			titan.Unfreeze()
		titan.Destroy()
	}
}

function NuclearCoreExplosion( vector origin, e )
{
	entity titan = expect entity( e.titan )

	titan.EndSignal( "OnDeath" )

	e.needToClearNukeFX = false //This thread and NuclearCoreExplosionChainReaction now take responsibility for clearing the FX

	OnThreadEnd(
		function() : ( e )
		{
			ClearNuclearBlueSunEffect( e )
		}
	)

	wait 1.3
	Assert( IsValid( titan ) )
	titan.s.silentDeath <- true  //Don't play normal titan_death_explode in _deathpackage since we're playing titan_nuclear_death_explode

	EmitSoundAtPosition( titan.GetTeam(), origin, "titan_nuclear_death_explode" )

	titan.s.noLongerCountsForLTS <- true

	thread NuclearCoreExplosionChainReaction( origin, e )

	// modified here: this type of kill will make titan invalid immediately
	// to handle nuke damage properly, kill them after nuke
	bool freezeDuringNuke = false
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
		freezeDuringNuke = true
	if ( IsAlive( titan ) )
	{
		// if we want to freeze titan during nuke explosions, don't do DMG_REMOVENORAGDOLL
		if ( freezeDuringNuke )
			titan.Die( e.attacker, e.inflictor, { scriptType = DF_EXPLOSION, damageSourceId = e.damageSourceId } )
		else // vanilla behavior
			titan.Die( e.attacker, e.inflictor, { scriptType = DF_EXPLOSION, damageType = DMG_REMOVENORAGDOLL, damageSourceId = e.damageSourceId } )
	}
}

function TitanEjectPlayerForNPCs( entity ejectTitan, bool instant = false ) //TODO: This needs a refactor badly. Way too long and unwieldy. I think it was a mistake to handle both player Titan eject and NPC titan eject in the same function
{
	ejectTitan.Signal( "EjectAttempt" )

	Assert( ejectTitan.IsTitan() )
	Assert( IsAlive( ejectTitan ), "Ejecting titan expected to be alive. IsPlayer? " + ejectTitan.IsPlayer() + " ent: " + ejectTitan )

	if ( ejectTitan.ContextAction_IsActive() )
		return

	entity soul = ejectTitan.GetTitanSoul()

	if ( soul.IsEjecting() )
		return

	if ( ejectTitan.IsPlayer() )
	{
		if ( IsPlayerDisembarking( ejectTitan ) )
			return
	}

	local e = {}
	e.titan <- ejectTitan
	e.team <- ejectTitan.GetTeam()

	e.player <- null
	e.npcPilot <- null
	// modified, make it be in table
	//bool ejectTitanHasNpcPilot = false
	e.ejectTitanHasNpcPilot <- false
	if ( ejectTitan.IsPlayer() )
		e.player = ejectTitan
	
	// modified: throw a ragdoll if we've disabled this titan's pilot combat
	e.pilotModel <- null

		if ( TitanHasNpcPilot( ejectTitan ) )
		{
			// modified, make it be in table
			//ejectTitanHasNpcPilot = true
			e.ejectTitanHasNpcPilot = true
			// vanilla missing. this can fix titan firing weapon during animation
			ejectTitan.kv.allowShoot = 0
			ForceTitanSustainedDischargeEnd( ejectTitan )
		}

	e.nukeFX <- []
	e.attacker <- ( "attacker" in soul.lastAttackInfo ) ? soul.lastAttackInfo.attacker : null
	e.inflictor <- ( "inflictor" in soul.lastAttackInfo ) ? soul.lastAttackInfo.inflictor : null
	e.damageSourceId <- ( "damageSourceId" in soul.lastAttackInfo ) ? soul.lastAttackInfo.damageSourceId : -1
	e.damageTypes <- soul.lastAttackInfo.scriptType
	e.overrideAttacker <- soul.soul.nukeAttacker

	// modified to make mp_titanability_nuke_eject work
	e.hasNuclearCore <- false
	if ( ejectTitan.IsPlayer() )
	{
		if ( PlayerHasWeapon( ejectTitan, "mp_titanability_nuke_eject" ) ) // if player has nuke_eject weapon...
		{
			// have to manually doom it since undoomed titan will return a 0 in GetNuclearPayload()
			// still can't make client predict the animation though, why respawn have to do this weapon all on client
			soul.EnableDoomed()
			ejectTitan.SetDoomed()
			DoomTitan( ejectTitan )
			// PAS_BUILD_UP_NUCLEAR_CORE is ttf2's nuke, PAS_NUCLEAR_CORE is super nuke!
			if ( PlayerHasPassive( ejectTitan, ePassives.PAS_BUILD_UP_NUCLEAR_CORE ) )
				e.hasNuclearCore = true // mark as already has a nuclear core, we won't remove it after ejecting
			else
				GivePassive( ejectTitan, ePassives.PAS_BUILD_UP_NUCLEAR_CORE ) // temp give NUCLEAR_CORE to player
		}
	}
	//

	local nuclearPayload = 0
	if ( IsValid( e.player ) )
		nuclearPayload = GetNuclearPayload( ejectTitan )
	else
		nuclearPayload = NPC_GetNuclearPayload( ejectTitan )

	e.nuclearPayload <- nuclearPayload

	if ( e.nuclearPayload )
	{
		e.needToClearNukeFX <- false
		e.nukeFXInfoTarget <- CreateEntity( "info_target" )
		e.nukeFXInfoTarget.kv.spawnflags = SF_INFOTARGET_ALWAYS_TRANSMIT_TO_CLIENT
		DispatchSpawn( e.nukeFXInfoTarget )

		// modified here: handle nuke damage override
		// needs testing on this damagearea thing... do they really work when their parent updates position later?
		/*
		if ( SoulHasNukeDamageOverride( soul ) )
			AI_CreateDangerousArea( e.nukeFXInfoTarget, ejectTitan, float( GetSoulNukeDamageOverride( soul ).outerRadius ), ejectTitan.GetTeam(), true, true )
		else // vanilla behavior
			AI_CreateDangerousArea_DamageDef( damagedef_nuclear_core, e.nukeFXInfoTarget, ejectTitan.GetTeam(), true, true )
		*/
	}

	entity rodeoPilot = GetRodeoPilot( ejectTitan )
	if ( rodeoPilot && rodeoPilot == e.attacker )
		e.damageSourceId = eDamageSourceId.rodeo_forced_titan_eject
	
	ejectTitan.EndSignal( "OnDeath" )

	ejectTitan.Signal( "TitanEjectionStarted" )
	//ejectTitan.EndSignal( "OnDeath" ) // moved up

	OnThreadEnd(
		function() : ( e, ejectTitan )
		{
			if ( IsAlive( ejectTitan ) )
			{
				thread ClearEjectInvulnerability( ejectTitan )

				// modified to make nuke_eject work
				if ( ejectTitan.IsPlayer() )
				{
					if ( !e.hasNuclearCore ) // don't have a nuclear core at start
						TakePassive( ejectTitan, ePassives.PAS_BUILD_UP_NUCLEAR_CORE ) // take the passive off player
				}
				// vanilla missing npc pilot logic
					if ( expect bool( e.ejectTitanHasNpcPilot ) )
					{
						// vanilla missing: npc pilot ejecting protection
						entity npcPilot = expect entity( e.npcPilot )
						if ( IsAlive( npcPilot ) )
							thread ClearEjectInvulnerability( npcPilot )
						// vanilla missing: give back weapon usage after ejecting
						if ( IsAlive( ejectTitan ) )
							ejectTitan.kv.allowShoot = 1
					}
			}
			else if ( IsValid( ejectTitan ) )
			{
				ejectTitan.ClearInvulnerable()
			}

			if ( IsValid( e.player ) )
			{
				e.player.UnfreezeControlsOnServer()
			}

			entity titan = expect entity( e.titan )

			if ( e.nuclearPayload )
			{
				if ( e.needToClearNukeFX )
				{
					if ( IsAlive( titan ) )
					{
						//Nuclear eject sequence got interrupted early, probably because Pilot died
						Assert( titan.IsTitan() )
						thread NuclearCoreExplosion( titan.GetOrigin(), e )
					}
					else
					{
						//Nuclear eject fired, needs to be cleaned up
						ClearNuclearBlueSunEffect( e )
					}
				}
				//Nuclear core handles cleaning up the left over titan by itself, so just return out early
				return
			}

			if ( !IsAlive( titan ) )
				return

			entity soul = titan.GetTitanSoul()
			if ( !soul.soul.diesOnEject )
				return

			Assert( titan.IsTitan() )
			Assert( soul.IsEjecting() )
			titan.Die( e.attacker, e.inflictor, { scriptType = damageTypes.titanEjectExplosion | e.damageTypes, damageSourceId = e.damageSourceId } )
		}
	)

	soul.SetEjecting( true )
	ejectTitan.SetInvulnerable()  //Give both player and ejectTitan temporary invulnerability in the course of ejecting. Player invulnerability gets cleared in ClearEjectInvulnerability

	#if SERVER
		StatusEffect_StopAll( expect entity( e.titan ), eStatusEffect.lockon_detected_titan )
	#endif

	#if HAS_STATS
	if ( IsValid( e.player ) )
	{
		UpdatePlayerStat( expect entity( e.player ), "misc_stats", "timesEjected" )
		if ( nuclearPayload )
			UpdatePlayerStat( expect entity( e.player ), "misc_stats", "timesEjectedNuclear" )
	}
	#endif
	#if SERVER && MP
		PIN_AddToPlayerCountStat( expect entity( e.player ), "ejects" )
	#endif

	if ( !ejectTitan.ContextAction_IsBusy() )
		ejectTitan.ContextAction_SetBusy()

	local standing = true
	if ( IsValid( e.player ) )
		standing = e.player.IsStanding()
	else
		standing = soul.GetStance() == STANCE_STAND

	local titanEjectAnimPlayer, titanEjectAnimTitan
	if ( standing )
	{
		if ( nuclearPayload )
		{
			titanEjectAnimPlayer = "at_nuclear_eject_standing"
			titanEjectAnimTitan = "at_nuclear_eject_standing_idle"
		}
		else
		{
			titanEjectAnimPlayer = "at_MP_eject_stand_start"
			titanEjectAnimTitan = "at_MP_eject_stand_end"
		}
	}
	else
	{
		// be sure to set up standing stance in NpcPilotEmbarksTitan()
		titanEjectAnimPlayer = "at_MP_eject_crouch_idle"
		titanEjectAnimTitan = "at_MP_eject_crouch_start"
	}

	float ejectDuration // = TITAN_PLAYEREJECT_DURATION
	if ( nuclearPayload )
		ejectDuration = TITAN_PLAYEREJECT_DURATION * 2.0
	else
		ejectDuration = TITAN_PLAYEREJECT_DURATION

//	ejectDuration = ejectTitan.GetSequenceDuration( titanEjectAnimPlayer )

	if ( nuclearPayload )
	{
		array<entity> players = GetPlayerArray()
		local frequency = 40
		local duration = 8.5
		vector origin = ejectTitan.GetOrigin()

		foreach ( guy in players )
		{
			if ( guy == e.player )
				continue

			if ( !IsAlive( guy ) )
				continue

			float dist = Distance( guy.GetOrigin(), origin )
			float result = Graph( dist, 750, 1500, 5.0, 0.0 )
			Remote_CallFunction_Replay( guy, "ServerCallback_ScreenShake", result, frequency, duration )
		}

		e.needToClearNukeFX = true
		e.nukeFXInfoTarget.SetParent( ejectTitan, "CHESTFOCUS" ) //Play FX and sound on entity since we need something that lasts across the player titan -> pilot transition
		e.nukeFX.append( PlayFXOnEntity( TITAN_NUCLEAR_CORE_NUKE_FX, expect entity( e.nukeFXInfoTarget ) ) )
		e.nukeFX.append( e.nukeFXInfoTarget )
		//ejectDuration += 0.5

		EmitSoundOnEntity( e.nukeFXInfoTarget, "titan_nuclear_death_charge" )
	}

	entity rodeoPlayer = GetRodeoPilot( ejectTitan )
	if ( IsValid( rodeoPlayer ) )
		Remote_CallFunction_Replay( rodeoPlayer, "ServerCallback_RodeoerEjectWarning", ejectTitan.GetTitanSoul().GetEncodedEHandle(), TITAN_PLAYEREJECT_DELAY + ejectDuration )

	if ( IsValid( e.player ) )
		e.player.CockpitStartEject()

	float blendDelay = 0.15
	vector origin = ejectTitan.GetOrigin()

	if ( !instant )
	{
		if ( IsValid( e.player ) )
		{
			Remote_CallFunction_Replay( e.player, "ServerCallback_EjectConfirmed" )
			EmitSoundAtPositionExceptToPlayer( e.team, ejectTitan.GetOrigin(), e.player, "Titan_Eject_Servos_3P" )
			e.player.FreezeControlsOnServer()
		}
		else
		{
			EmitSoundAtPosition( e.team, ejectTitan.GetOrigin(), "Titan_Eject_Servos_3P" )
		}

		if ( !ejectTitan.IsTitan() )
		{
			// must be a titan, something bad has happened
			KillStuckPlayer( ejectTitan )
			return
		}

		// vanilla missing behavior: if it's a npc, should do Anim_ScriptedPlay
		// much like third person animation below( which uses wrapped firstperson sequence func )
		// now adding a setting that allows npc to not doing Anim_ScriptedPlay()
		// because vanilla nuke titans can move during eject animation, don't want to break that behavior
		bool npcStopsMoving = true // vanilla behavior
		if ( npcStopsMoving && ejectTitan.IsNPC() )
		{
			// maybe no need to setup a full sequence this, just do Anim_ScriptedPlay
			/*
			FirstPersonSequenceStruct sequence
			sequence.thirdPersonAnim = expect string ( titanEjectAnimPlayer )
			sequence.teleport = true
			thread FirstPersonSequence( sequence, ejectTitan )
			*/
			ejectTitan.Anim_ScriptedPlay( titanEjectAnimPlayer )
		}
		else
			ejectTitan.Anim_Play( titanEjectAnimPlayer ) // player don't have control at this point, anim_play is enough

		wait blendDelay  // wait for ejectTitan to blend into disembark pose

	    Assert( ejectDuration > MAX_EJECT_LATENCY_COMPENSATION )
	    wait ejectDuration - MAX_EJECT_LATENCY_COMPENSATION

	    if ( IsValid( e.player ) )
	    {
		    // subtract player latency so that the client gets the eject at the same time they finish the animation
		    float latency = expect entity( e.player ).GetLatency()
		    float waitduration = MAX_EJECT_LATENCY_COMPENSATION - min( latency, MAX_EJECT_LATENCY_COMPENSATION )
		    //printt( "Eject: compensating for " + latency + " seconds of latency; wait " + waitduration )
		    wait waitduration
		}
	}

	// Defensive fix for if player becomes a spectator between initiating eject and now
	if ( IsValid( e.player ) && e.player.GetPlayerSettings() == "spectator" )
		return

	if ( ejectTitan.GetTitanSoul() == null )
		return

	if ( IsValid( e.player ) )
		EmitSoundAtPositionExceptToPlayer( e.team, ejectTitan.GetOrigin(), e.player, "Titan_Eject_PilotLaunch_3P" )
	else
		EmitSoundAtPosition( e.team, ejectTitan.GetOrigin(), "Titan_Eject_PilotLaunch_3P" )

	entity titan
	if ( IsValid( e.player ) )
	{
		entity player = expect entity( e.player )
		titan = CreateAutoTitanForPlayer_ForTitanBecomesPilot( player )
		DispatchSpawn( titan )
		player.p.lastEjectTime = Time()
		HolsterAndDisableWeapons( player ) //Primarily done to not play the holster animation, then deploy animation of weapon if we happened to switch the active weapon in GiveWeaponsFromStoredArray()
		TitanBecomesPilot( ejectTitan, titan )
		DeployAndEnableWeapons( player )//Undo Holster
		player.UnfreezeControlsOnServer()
	}
	else
	{
		// the titan is an AI
		titan = ejectTitan
	}

		// modified, make it be in table
		//if ( ejectTitanHasNpcPilot )
		if ( expect bool( e.ejectTitanHasNpcPilot ) )
		{
		e.npcPilot = NpcTitanBecomesPilot( ejectTitan )
		entity npcPilot = expect entity( e.npcPilot )
		if ( IsAlive( npcPilot ) )
			npcPilot.SetInvulnerable()
		}

	vector titanOrigin = titan.GetOrigin()

	// HACKY, surprised there isn't a wrapper for this yet
	if ( !( "disableAutoTitanConversation" in titan.s ) )
		titan.s.disableAutoTitanConversation <- true // no auto titan chatter

	titan.SetInvulnerable() //Titan dies at the end of eject sequence by script
	titan.SetNPCPriorityOverride_NoThreat()	// AI shouldn't consider this ejecting titan as an enemy and shoot it, etc

	if ( e.nuclearPayload )
	{
		e.nukeFXInfoTarget.SetParent( titan, "CHESTFOCUS" )
	}

	local isInDeepWater = ( "isInDeepWater" in ejectTitan.s && ejectTitan.s.isInDeepWater )

	if ( e.nuclearPayload || isInDeepWater )
	{
		thread TitanNonSolidTemp( titan )
	}

	ejectTitan.Anim_Stop()
	e.titan = titan

	if ( ejectTitan.ContextAction_IsBusy() )
		ejectTitan.ContextAction_ClearBusy()

	FirstPersonSequenceStruct sequence
	sequence.thirdPersonAnim = expect string ( titanEjectAnimTitan )
	sequence.teleport = true
	thread FirstPersonSequence( sequence, titan )

	if ( IsValid( e.player ) )
	{
		entity player = expect entity( e.player )
		thread TempAirControl( player )

		PutEntityInSafeSpot( player, titan, null, origin + <0,0,60>, player.GetOrigin() + <0,0,60> )
	}

	vector ejectAngles = titan.GetAngles()
	ejectAngles.x = 270
	//ejectAngles.x = RandomIntRange( 263, 277 ) //5 degrees back of straight up was 245

	float speed = RandomFloatRange( 1500, 1700 ) //was 1000
	if ( nuclearPayload )
		speed += 400

	if ( isInDeepWater )
		speed += 1000

	e.singleRodeoPilot <- null //HACKY. Need to store it off because after time passes we don't have a handle to the rider anymore. Terribly hacky

	entity rider = GetRodeoPilot( titan )
	if ( rider && rider.GetParent() == titan )
	{
		e.singleRodeoPilot = rider //Need to store it off because after time passes we don't have a handle to the rider anymore. Terribly hacky
		if ( IsValid( e.player ) )
			thread TemporarilyNonSolidPlayer( expect entity( e.player ) )

		thread TemporarilyNonSolidPlayer( rider )

		vector riderEjectAngles = AnglesCompose( ejectAngles, < 5, 0, 0 > )

		float gravityScale = expect float ( rider.GetPlayerSettingsField( "gravityscale" ) )
		vector riderVelocity = AnglesToForward( riderEjectAngles ) * (speed * gravityScale) * 0.95

		ThrowRiderOff( rider, titan, riderVelocity )

		wait 0.05
	}

	if ( IsAlive( expect entity( e.player ) ) )
	{
		if ( PlayerHasPassive( expect entity( e.player ), ePassives.PAS_PHASE_EJECT ) )
		{
			PhaseShift( expect entity( e.player ), 0.0, 3.0 )
			ejectAngles.x = 315
			speed *= 0.5
		}
		ejectAngles = AnglesCompose( ejectAngles, < -5, 0, 0 > )

		float gravityScale = expect float ( e.player.GetPlayerSettingsField( "gravityscale" ) )
		vector velocity = AnglesToForward( ejectAngles ) * speed * sqrt( gravityScale )
		e.player.SetOrigin( e.player.GetOrigin() )
		e.player.SetVelocity( velocity )
		vector player_look_angles = titan.GetAngles()
		player_look_angles.x = 80  //was 35
		e.player.SetAngles( player_look_angles )

		thread EjectFlightTracker( expect entity( e.player ) )

		entity rider = expect entity( e.singleRodeoPilot )
		if ( IsAlive( rider ) && e.player.GetTeam() != rider.GetTeam() )
			thread LookAtEachOther( rider, expect entity( e.player ) )
	}
	// modified version of npc pilot ejecting
		// modified, make it be in table
		//else if ( ejectTitanHasNpcPilot && IsAlive( expect entity( e.npcPilot ) ) )
		else if ( expect bool( e.ejectTitanHasNpcPilot ) && IsAlive( expect entity( e.npcPilot ) ) )
		{
			//speed *= 0.6 //vanilla magic number, too slow so modified to removed it
			vector velocity = < 0, 0, speed > //straight up
			e.npcPilot.SetOrigin( titan.GetOrigin() + Vector(0,0,100) ) // my version used 300
			e.npcPilot.SetAngles( titan.GetAngles() )
			// don't really have such animation
			//e.npcPilot.Anim_ScriptedPlay( "running_jump_F_float" )
			e.npcPilot.SetVelocity( velocity )

			// modified here: use npc pilot as explosion attacker
					e.overrideAttacker = e.npcPilot
		}
		else if ( IsValid( e.pilotModel ) ) // just for fun here: throw a ragdoll outside from titan
		{
			vector velocity = < 0, 0, speed * 100 > //straight up
			e.pilotModel.SetOrigin( titan.GetOrigin() + Vector(0,0,100) )
			e.pilotModel.SetAngles( titan.GetAngles() )
			e.pilotModel.BecomeRagdoll( velocity, false )
		}

	if ( IsValid( e.player ) )
		TitanEjectVO( expect entity( e.player ), titanOrigin )

	wait 0.15

	vector explosionOrigin = titanOrigin + Vector( 0, 0, 200 )

	if ( nuclearPayload )
	{
		thread NuclearCoreExplosion( explosionOrigin, e )
	}
	else
	{
		entity explosionOwner = GetExplosionOwner( e )
		entity inflictor
		if ( IsValid( titan ) )
			inflictor = titan
		else
			inflictor = explosionOwner

		// modified settings override: eject damage
			RadiusDamage(
				explosionOrigin,				// origin
				explosionOwner,					// owner
				inflictor,		 				// inflictor
				1,								// normal damage
				1800,							// heavy armor damage
				100,							// inner radius
				300,							// outer radius
				SF_ENVEXPLOSION_NO_DAMAGEOWNER,	// explosion flags
				0, 								// distanceFromAttacker
				0, 								// explosionForce
				damageTypes.explosive,			// damage flags
				eDamageSourceId.titan_explosion	// damage source id
			)

		entity shake = CreateEntity( "env_shake" )
		shake.SetOrigin( titanOrigin )
		shake.kv.amplitude = 12  //1-16
		shake.kv.duration = 1
		shake.kv.frequency = 100 //.001 - 255
		shake.kv.radius = 1000
		shake.kv.spawnflags = 4 //in air
		DispatchSpawn( shake )
		shake.Fire( "StartShake" )
		shake.Kill_Deprecated_UseDestroyInstead( 1 )
	}

	if ( IsValid( titan ) )
	{
		if ( titan.ContextAction_IsBusy() )
			titan.ContextAction_ClearBusy()
	}
}

void function KillStuckPlayer( entity player )
{
	if ( IsAlive( player ) )
		player.Die( svGlobal.worldspawn, svGlobal.worldspawn, { scriptType = DF_DISSOLVE, damageSourceId = damagedef_crush } )
}

entity function GetExplosionOwner( e )
{
	if ( IsValid( expect entity( e.overrideAttacker ) ) )
		return expect entity( e.overrideAttacker )

	if ( IsValid( expect entity( e.player ) ) )
		return expect entity( e.player )

	if ( IsValid( expect entity( e.titan ) ) )
		return expect entity( e.titan )

	return GetTeamEnt( expect int( e.team ) )
}
